\documentclass[a4paper,12pt]{article}

% Para usar a linguagem PT-BR.
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{tikz}
\usepackage[brazilian]{babel}
\usepackage[linesnumbered,ruled]{algorithm2e}
\usepackage{amsmath, amsthm, amssymb}

\selectlanguage{brazilian} 

\newtheorem{lem}{Lema}
\newtheorem{prov}{Prova}
\newtheorem{alg}{Análise do algoritmo}

\newcommand{\Oh}{\mathrm{O}}

\sloppy

\begin{document}
\begin{center}
   {\large \textbf{UNIVERSIDADE DE SÃO PAULO}} \\[1.4cm]
   
   {\large \textbf{INSTITUTO DE MATEMÁTICA E ESTATÍSTICA}}\\[4.2cm]
   
   {\Huge TRABALHO DE CONCLUSÃO }\\[0.3cm]
   {\Huge DE CURSO }\\[9cm]
   
   {\large { Aluna: Karina Suemi Awoki}}\\[0.3cm]
   
   {\large { Orientadora: Cristina Gomes Fernandes}}
   

\end{center}

\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%  INTRODUÇÃO  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Introdução}

O assunto abordado no Trabalho de Conclusão de Curso se
enquadra na área de Otimização Combinatória e diz respeito ao 
\emph{Problema da Bissecção Mínima}. Para definir o problema 
precisamente, seguem primeiro algumas definições. 

Seja $G=(V,E)$ um grafo e $S$ um conjunto de vértices de $G$ tal 
que~${\emptyset \neq S \subset V}$. 
Denota-se por $\delta(S)$ o conjunto das arestas de $G$ com 
exatamente um extremo em $S$. Um \emph{corte} em $G$ é um conjunto
$C$ de arestas tal que~${C = \delta(S)}$ para algum conjunto $S$ 
de vértices de $G$ com $\emptyset \neq S \subset V$. 
Denota-se por $\bar{S}$ o conjunto $V \setminus S$. 
Note que $\delta(\bar{S}) = C$ também. 
O par de conjuntos $S$ e $\bar{S}$ é chamado de 
\emph{par de margens} de $C$. 
Note que se $G$ não é conexo, um corte pode ter mais de um par de 
margens. 
O corte $C$ é uma \emph{bissecção} se possui um par de margens $S$ 
e $\bar{S}$ tal que $||S|- |\bar{S}|| \in \{0,1\}$, ou seja, $S$ e 
$\bar{S}$ particionam o grafo basicamente ao meio. 
O número $|C|$ é chamado de \emph{largura} do corte $C$. 

O \emph{Problema da Bissecção Mínima} consiste em, dado um grafo, 
encontrar uma bissecção no grafo de largura mínima.

Sabe-se que o problema da bissecção é NP-difícil~\cite{GareyJS76} 
e a melhor aproximação conhecida para o caso geral do problema tem 
razão $\Oh(\lg n)$~\cite{Racke08}, onde $n$ é o número de vértices 
do grafo. 
Por outro lado, sabe-se que, para árvores e grafos que de uma 
certa maneira se assemelham a árvores, há um algoritmo polinomial 
de programação dinâmica para encontrar uma bissecção mínima, 
proposto por Jansen, Karpinski, Lingas e 
Seidel~\cite{JansenKLS01}. 

Fernandes, Schmidt e Taraz têm interesse em entender a estrutura 
dos grafos cuja bissecção mínima tem largura grande, de modo a 
desenvolver bons algoritmos de aproximação para o problema ou 
identificar melhor as classes de grafos onde o problema torna-se 
especialmente difícil. 
Para tanto, eles têm feito estudos de certas questões em árvores, 
em grafos que têm uma estrutura semelhante às árvores, e também em 
grafos planares~\cite{FernandesST13,FernandesST15}, para os quais 
a complexidade do problema encontra-se em aberto. 

Vários outros resultados são conhecidos para o Problema da 
Bissecção Mínima, porém este trabalho de conclusão de curso se 
concentrou no estudo do problema em árvores.

\newpage


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%   OBJETIVOS  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Objetivos} 

O principal objetivo deste trabalho foi o estudo, implementação e 
análise de um algoritmo recente, proposto por Fernandes, Schmidt e 
Taraz~\cite{FernandesST13}, para encontrar uma bissecção 
aproximadamente mínima em árvores de grau limitado, denotaremos
esse algoritmo por FST. 
A vantagem deste algoritmo sobre o algoritmo de Jansen et 
al.~\cite{JansenKLS01}, que encontra uma bissecção de largura 
mínima, é que este tem um consumo de tempo linear, enquanto que o 
segundo tem um consumo de tempo cúbico no número de vértices da 
árvore. 
Implementamos também o algoritmo de Jansen et al., para fins de 
comparação da largura das bissecções produzidas pelo algoritmo
FST. 

Como já mencionado, o algoritmo de Jansen et al.\ baseia-se em 
programação dinâmica. 
Já o algoritmo de Fernandes et al., para atingir um consumo 
linear, utiliza técnicas bem conhecidas de percursos de árvore, 
como busca em profundidade, bem como um rastreamento de 
informações mais cuidadoso que permite que o processamento todo 
seja executado em tempo linear. 
É um algoritmo mais refinado, dividido na implementação de uma 
série de etapas menores. 

Uma vez implementados os dois algoritmos, foi feita uma análise 
da sua performance em árvores binárias geradas aleatoriamente, e 
em árvores ternárias.
Obtivemos instâncias reais de um problema relacionado e as 
utilizamos também no estudo experimental do algorimo implementado.
 

\newpage


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%  MÉTODO  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Método}

O estudo do algoritmo de Fernandes et al.\ seguiu um roteiro de
como a implementação foi feita, conforme a proposta do TCC. 
A linguagem escolhida para a implementação foi \texttt{C} e os 
algoritmos implementados foram colocados na página do gitHub. 
O roteiro consistiu em uma divisão da implementação do algoritmo 
em várias etapas, que permitiu um melhor acompanhamento do 
trabalho desenvolvido, e uma organização da forma de estudo. 
O algoritmo encontra-se descrito em um documento 
longo~\cite{Schmidt15} juntamente com a sua análise teórica. 
Este documento serviu como base para o entendimento de cada 
etapa, e de como a implementação de cada etapa deveria ser feita 
para que a implementação obtida fosse de fato linear. 

Reuniões frequentes foram feitas junto à supervisora para 
apresentar as etapas já implementadas, bem como para tirar dúvidas 
sobre as próximas etapas ou detalhes da implementação. 
Em maio e junho, Tina Schmidt, uma das autoras do algoritmo que 
foi implementado, visitou o IME, e a parte da 
implementação que estava pronta foi apresentada a ela, e 
algumas discussões foram feitas e em especial, a Tina conseguiu
um conjunto de instâncias reais com BLA para usarmos em nossos
experimentos.   

Em paralelo ao estudo e desenvolvimento da implementação, foram 
estudados também dois artigos da literatura. São eles o artigo 
de Garey, 
Johnson e Stockmeyer~\cite{GareyJS76}, que contém a prova de que o 
problema é NP-difícil, e o artigo de Jansen et al., que apresenta 
o algoritmo de programação dinâmica para o problema em árvores. 
Após a implementação do algoritmo de Fernandes et~al., foi feita 
a implementação do algoritmo de Jansen et~al.\ e a comparação dos 
dois. 

\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%  DEFINIÇÕES  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Definições}
		
	Para um grafo $G$, denotamos seu
	conjunto de vértices por $V(G)$ e seu
	conjunto de arestas por $E(G)$.

	\bigskip

	Dizemos que $(B,W)$ é um 
	\textbf{corte}
	de $G$ se $B \cup W = V(G)$ e $B \cap W = \emptyset$.
	Denotamos por $e_G(B,W)$ o número de arestas no corte $(B,W)$.

	\bigskip

	O número de arestas que incidem em um determinado
	vértice $v$ é chamado de 
	\textbf{grau} de $v$ e será representado
	por $grau(v)$. O 
	\textbf{grau máximo}, que é o grau de um vértice de
	maior grau em $G$, será representado por $\Delta(G)$.

	\bigskip

	Um \textbf{caminho} em uma árvore $T$, de 
	comprimento $p$, é uma sequência de vértices 
	$v_0, v_1, \ldots,v_{p-1}, v_p$ 
	onde {$v_{k-1}, v_k$} é uma aresta para todo 
	$k = 1,2, \ldots, p$. 
	Como existe um único caminho que conecta quaisquer dois 
	vértices $v_0$ e $v_p$ em $T$, chamaremos tal 
	caminho em $T$ de  
	$v_0$,$v_p$-\textbf{caminho}.

	\bigskip

	A \textbf{distância} entre dois vértices $a$ e 
	$b$ de T é representada por 
	$dist(a,b)$, e é igual ao comprimento do
	$a$,$b$-caminho em $T$.

		

\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%  SEÇÃO 5     %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Caminho máximo em árvores}

	Um \textbf{caminho máximo} em uma árvore $T$ é um caminho em 
	$T$ de comprimento máximo.

	Encontrar um caminho máximo em uma árvore $T=(V,E)$ é uma tarefa
	computacionalmente simples que pode ser realizada em tempo 
	$O(n)$, sendo $n$ o número de vértices de $T$, ou seja, 
	$n = |V|$. 
	Primeiramente escolhe-se um vértice arbitrário
	$v \in V$ e encontra-se um vértice $y_0$ mais distante de 
	$v$.
	Depois, repetimos o mesmo processo a partir de $y_0$, 
	encontrando um vértice
	$x_0$ mais distante de $y_0$. 
	Para encontrar um vértice mais distante de algum vértice dado, 
	basta usar uma busca em largura.  
	Feito isso, temos um caminho máximo em $T$: o único
	caminho que liga $x_0$ a $y_0$.

	\bigskip

	\begin{lem}
		O $x_0$,$y_0$-caminho é um caminho máximo em $T$.
	\end{lem}

	\bigskip

	\begin{proof}
		Suponhamos que exista um outro caminho mais longo que o
		$x_0$,$y_0$-caminho e sejam $x$ e $y$ os seus extremos.

		\begin{itemize}
	        \item \textbf{Caso 1:} O $x$,$y$-caminho e o 
	        $x_0$,$y_0$-caminho não possuem vértices em comum.

	        Existe um $a$,$b$-caminho, de 
	        comprimento $c \ge 1$, que conecta os dois caminhos, 
	        possuindo assim apenas o vértice $a$ no 
	        $x$,$y$-caminho e apenas o vértice $b$ no
	        $x_0$,$y_0$-caminho.

	        \begin{center} \begin{tikzpicture}
				[scale=.8,auto=left,every node/.style={circle,
				fill=blue!20}]
				\node (x) at (0,5)  {$x$};
				\node (y) at (12,5) {$y$};
				\node (a) at (6,4)  {$a$};
				  
				\node (x0) at (0,0) {$x_0$};
				\node (y0) at (12,0) {$y_0$};
				\node (b)  at (6,1)  {$b$};

				\node (n1) at (3,4.5) {...}; %entre x e a 
				\node (n2) at (9,4.5) {...}; %entre a e y
				\node (n3) at (3,0.5) {...}; %entre x0 e b
				\node (n4) at (9,0.5) {...}; %entre y0 e b
				\node (n5) at (6,2.5) {...}; %entre a e b

				\foreach \from/\to in {x/n1,n1/a,a/n2,n2/y,x0/n3,
				n3/b,b/n4,n4/y0,a/n5,b/n5}
				\draw (\from) -- (\to);
			\end{tikzpicture} \end{center}


	        Portanto temos que
	        $ dist(x,y) = dist(x,a) + dist(a,y) $ e
	        $ dist(x_0,y_0) = dist(x_0,b) + dist(b,y_0)$.

	        Como o $x$,$y$-caminho é máximo, 
	        $ dist(x,y)\ge dist(x_0,y)$,
	        e isso implica que
	        $ dist(x,a)\ge dist(x_0,b)+c$.

	        Como $x_0$ é um vértice mais distante de $y_0$, temos que 
	        $ dist(x_0,y_0)\ge dist(x,y_0)$, que implica que
	        $ dist(x_0,b)\ge dist(x,a)+c$.
	        Logo temos que
	        $ dist(x,a)\ge dist(x, a)+2c$,
	        uma contradição, visto que
			$c\ge 1$.


			\bigskip
			\bigskip
			\bigskip


			\item \textbf{Caso 2:} O $x$,$y$-caminho e o 
			$x_0$,$y_0$-caminho possuem vértices em comum.

			A interseção entre esses dois caminhos é um 
			$a$,$b$-caminho de comprimento $c \ge 0$.
			Podemos assumir, sem perda de generalidade, que
			$dist(x,a) \le dist(x,b)$ e que
			$dist(x_0,a) \le dist(x_0,b)$, como na figura abaixo.
			(Do contrário troque $a$ por $b$ e possivelmente $x$
			por $y$.)

			\begin{center} \begin{tikzpicture}
				[scale=.8,auto=left,every node/.style={circle,
				fill=blue!20}]
				\node (x) at (0,4)  {$x$};
				\node (y) at (12,4) {$y$};
				\node (a) at (4,4)  {$a$};
				\node (b) at (8,4)  {$b$};
				\node (x0) at (1.5,6)  {$x_0$};
				\node (y0) at (10.5,2)  {$y_0$};
				  
				\node (n1) at (2,4) {...};
				\node (n2) at (6,4) {...};
				\node (n3) at (10,4) {...};
				\node (n4) at (9.25,3) {...};
				\node (n5) at (2.75,5) {...};

				\foreach \from/\to in {x/n1,n1/a,a/n2,n2/b,b/n3,
				n3/y, a/n5,n5/x0,b/n4,n4/y0}
				\draw (\from) -- (\to);
			\end{tikzpicture} \end{center}


			Como $x_0$ é um vértice mais distante de $y_0$,
			temos que $dist(x_0,a) \ge dist(x,a)$.
			Por outro lado, como $x$ é um vértice mais distante
			de $y$, temos também que $dist(x,a)\ge dist(x_0,a)$,
			e portanto $dist(x_0,a) = dist(x,a)$.
			Similarmente, como $y$ é um vértice mais distante de
			$x$, vale que $dist(y,b) \ge dist(y_0,b)$.

			Agora consideremos o vértice $v$ que foi escolhido 
			arbitrariamente no início do algoritmo, e seja $v'$
			o vértice mais próximo de $v$ no $x_0$,$y_0$-caminho.
			Se $v'\ne b$, então, como $y_0$ é um vértice mais 
			distante de $v$,
			\begin{align}
				dist(v',y_0) &\ge dist(v',y) = dist(v',b) + dist(b,y)\nonumber \\
				&\ge dist(v',b) + dist(b,y_0) \ge dist(v',y_0) \nonumber,
			\end{align} 
			o que implica que $dist(v',y_0) = dist(v',y)$ assim
			como $ dist(b,y) = dist(b,y_0) $. 
			Ou seja, $dist(x,y) = dist(x_0,y_0)$.
			Resta analisar o caso em que $v'=b$ (é um caso especial,
			dado que pode-se ter arestas em comum entre $v$,$v'$-caminho 
			e o $y$,$b$-caminho).
			Como $y$ é um vértice mais distante de $x$, temos que 
			$dist(v',y_0) \le dist(v',y)$.
			Como $x_0$ é um vértice mais distante de $y_0$, temos
			que $dist(x_0,v') \ge dist(y,v')$.
			
			Finalmente, como $y_0$ é um vértice mais distante de 
			$v$, vale que $dist(y_0,v')\ge dist(x_0,v')$.

			Dessas três desigualdades, concluímos que 
			$dist(y_0,v') = dist(y,v') = dist(x_0,v') = dist(x,v') $,
			onde a última igualdade vale pois já mostramos que
			$ dist(x_0,a) = dist(x,a) $.

			Assim sendo $dist(x_0,y_0) = dist(x,y) $, completando a prova.

		\end{itemize}
	\end{proof}

	\bigskip
	\bigskip
	\bigskip
	\bigskip
	\bigskip
	\bigskip


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	Dizemos que o \textbf{diâmetro} de um grafo conexo $G$ é o
	comprimento de um caminho máximo de $G$. 
	Em outras palavras, o diâmetro pode ser definido como:
	$$ diam(G)=\max\{dist(x,y):x,y\in V(G)\}. $$

	\bigskip

	Seja $G$ um grafo não necessariamente conexo,
	o \textbf{diâmetro relativo} de $G$
	 é a razão entre o número
	de vértices de um caminho máximo e o número total de vértices
	de $G$. Este pode também ser representado por
	$$ diam^*(G) = \frac{\displaystyle\sum_{
	G'~componente~conexa~de~G}^{}(diam(G')+1)}{|V(G)|}. $$
    
\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%  SEÇÃO 6     %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section {Algoritmos de cortes aproximados}

Em \cite{Schmidt15}, são apresentados três algoritmos que, dada uma 
floresta $G$ e um inteiro $0<m\le n$, onde $n$ é o número de vértices 
de $G$, produzem cortes com algumas propriedades.

Abaixo reproduzimos os três resultados de \cite{Schmidt15} que 
atestam as propriedades dos cortes produzidos por estes algoritmos:

\bigskip
\bigskip
\bigskip
\bigskip

\begin{lem}[Lema do corte aproximado simples para árvores]

	Para toda árvore $T$ com $n$ vértices e todo $m \in [n]$,
	existe um corte $(B,W)$ em $T$ tal que 
	$\frac{m}{2} <|B| \le m$ e
	$e_T(B,W) \le \Delta(T)$.
	Um corte que satisfaz esses requisitos pode ser computado em
	tempo $O(n)$.
\end{lem}

\medskip

\begin{algorithm}[H]
	\SetKwInOut{Input}{input}
	\SetKwInOut{Output}{output}

	\caption{Computa corte aproximado}
	\Input{floresta $G = (V,E)$ com $n$ vértices, $m \in [n]$, 
	$c\in (\frac{1}{2}, 1)$}
	\Output{Um corte $(B,W)$ tal que $cm\le|B|\le m$}
	$B \gets \emptyset$\;
	\eIf{$c\le \frac{1}{2}$}{
		Encontrar um corte $(B',W')$ em $G$ com $\frac{m}{2} <|B'| \le m$ 
		(usando o Lema 2)\;
		
		$B \gets B'$\;
	}
	{
		\While{$|B|<cm$}{
			Encontrar um corte $(B',W')$ em $G[V-B]$ com 
			$\frac{m-|B|}{2} <|B'| \le m-|B|$ (usando o Lema 2)\;

			$B \gets B\cup B'$\;		
		}
	}
	\Return $(B,V-B)$

\end{algorithm}	

\medskip
\medskip

\textbf{Análise do Algoritmo}

	Suponha que $T=(V,E)$.
	É fácil ver que se $m=n$, então os valores $B = V$ e $W = \emptyset$ 
	satisfazem as condições do lema, dado que $e_G(B,W)$ será $0$. 
	Isso pode ser computado em tempo $O(n)$.

	Caso contrário, é necessário escolher uma raiz arbitrária $r$ para $T$
	e calcular o número de vértices das sub-árvores enraizadas 
	em cada um dos nós, que é o número de descendentes do nó.
	Isso serve para que saibamos a quantidade de vértices das sub-árvores
	sem que precisemos percorrer todos os nós das sub-árvores a cada consulta.

	Feito isso, temos que $v$ é o vértice analisado no momento e 
	$V_1, V_2, \ldots, V_k$ são as sub-árvores enraizadas nos $k$ filhos
	de $v$.
	Se algum $V_i$ satisfizer $\frac{m}{2}<|V_i|\le m$, podemos retornar
	a sub-árvore $|V_i|$ como sendo o conjunto $B$, satisfazendo o Lema 1,
	dado que o corte será $1$.
	Caso contrário, se $|V_i|> m$ para algum $i$, assumimos que 
	$v$ agora é a raiz de $V_i$ e aplicamos novamente esse processo em $v$.

	Nota-se que esse procedimento irá parar em algum momento, dado que a árvore 
	é finita, e ele parará quando encontrar
	uma sub-árvore que satisfaça o Lema 1 (e essa sub-árvore será o conjunto $B$) 
	ou quando chegarmos numa situação em que  
	$|V_i|\le \frac{m}{2}$ para todos os $k$ filhos de $v$.
	Nesse último caso, sabemos que $|V_1\cup V_2\cup \ldots \cup V_k|\ge m$, pois
	a sub-árvore enraizada em $v$ possui mais que $m$ vértices. 
	Sabemos também que $|V_i|\le \frac{m}{2}$ para todos os $k$ filhos de $v$. 
	Com isso, percorremos os $V_i$ em ordem, e 
	adicionamos $V_i$ ao conjunto $B$, parando antes que $|B| > m$. Isso nos dará
	$e_T(B,V-B) < v \le \Delta(T)$, o que satisfaz o lema.
	Sabemos que existe um $i$ tal que 
	$\frac{m}{2} < |V_1 \cup V_2 \cup \cdots \cup V_i| \le m$, pois a sub-árvore
	enraizada em $v$ possui mais que $m$ vértices e que se $|V_i|\le \frac{m}{2}$,
	então $|V_i \cup V_{i+1}| \le m$.


\bigskip
\bigskip
\bigskip
\bigskip
\bigskip
\bigskip
\bigskip
\bigskip
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%% LEMA 2 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lem}[Lema do corte aproximado simples {\cite[Lemma 2]{Schmidt15}}]

	Para toda floresta $G=(V,E)$ com $n$ vértices e todo $m \in [n]$,
	existe um corte $(B,W)$ em $G$ tal que 
	$\frac{m}{2} <|B| \le m$,
	$e_G(B,W) \le \Delta(G)$.
	Um corte que satisfaz esses requisitos pode ser computado em
	tempo $O(n)$.
\end{lem}

\medskip

Nota-se que esse lema é uma adaptação do anterior, trocando árvore
por floresta.

\medskip

\begin{alg}
	Temos que $T_1, T_2, \ldots,T_j $ são 
	as árvores de $G$. 
	Primeiro percorremos as árvores na ordem apresentada 
	anteriormente. Seja $l$ o maior inteiro tal que 
	$s = \displaystyle\sum_{i=1}^{l}|V(T_i)| \le m$,
	colocamos $T_1,T_2, \ldots,T_l$ no conjunto $B$.
	Caso $s=m$, temos $|B|=m$ com  $e_G(B,W)=0$, o que satisfaz o lema.
	Caso contrário, se encontrarmos um corte $(B',W')$ em $T_l+1$ que
	satisfaça $\frac{m-s}{2}<|B'|\le m-s$ com $e_{T_{l+1}}(B',W') \le 
	\Delta(T_{l+1})$, e acrescentarmos $B'$ no conjunto
	$B$, teremos
	$\frac{m+s}{2}<|B| \le m$ com 
	$e_G(B,W) = \Delta(T_{l+1}) \le \Delta(G)$.
	Logo, podemos acrescentar $B'$ em $B$ e teremos um corte
	que satisfaz o lema, e podemos fazer isso utilizando o Lema 1.

\end{alg}

\begin{algorithm}[H]
	\SetKwInOut{Input}{input}
	\SetKwInOut{Output}{output}

	\caption{Computa corte aproximado simples}
	\Input{floresta $G = (V,E)$ com $n$ vértices, $m \in [n]$, 
	$c\in (\frac{1}{2}, 1)$}
	\Output{Um corte $(B,W)$ tal que $m\le|B|\le m$}
	$B \gets \emptyset$\;

	\For{$i=1 \to k$, sendo $k$ o número de árvores}{
		\eIf{$|V_i| + |B|\le m$}{
			 $B \gets B\cup V_i$\;
		}	
		{
			Encontrar um corte $(B',W')$ em $G[V_i]$ com 
			$\frac{m-|B|}{2} <|B'| \le m-|B|$ (usando o Lema 2)\;

			$B \gets B\cup B'$\;

			break\;
		}	
	}
	\Return $(B,V-B)$\;

\end{algorithm}	

\bigskip
\bigskip
\bigskip
\bigskip
\bigskip
\bigskip
\bigskip
\bigskip

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%% LEMA 3 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lem}[Lema do corte aproximado {\cite[Lemma 3]{Schmidt15}}]

	Para toda floresta $G=(V,E)$ com $n$ vértices, todo $m \in [n]$
	e todo $c \in [0,1)$,
	existe um corte $(B,W)$ em $G$ tal que 
	$cm \le |B| \le m$,
	$e_G(B,W) \le \lceil \frac{2c}{1-c}\rceil \Delta(G)$.
	Um corte que satisfaz esses requisitos pode ser computado em
	tempo $O(n)$.
\end{lem}

\medskip

\begin{alg}
	
	Sabemos que se $c \le \frac{1}{2}$, podemos aplicar o Lema 2, 
	dado que o resultado nos dará um conjunto $B'$ tal que
	$|B'|>\frac{m}{2}\ge cm$.

	Inicialmente temos que $B = \emptyset$.
	Executaremos o Lema 2 diversas vezes para encontrar 
	um corte $(B',W')$ em $G[V-B]$ tal que $\frac{m-|B|}{2}<|B'|\le m-|B|$,
	acrescentando o conjunto $B'$ a $B$ em cada uma das chamadas ao Lema 2.
	Fazemos isso até que $|B|\ge cm$ seja satisfeito.
	Nota-se que em algum momento $|B|\ge cm$ irá ocorrer, pois a cada vez
	que executamos o Lema 2, acrescentamos pelo menos um vértice em $B$,
	e $|B|>m$ nunca irá ocorrer, pois o Lema 2 adicionará no máximo 
	$m-|B|$ vértices em $B$.

\end{alg}

\begin{algorithm}[H]
	\SetKwInOut{Input}{input}
	\SetKwInOut{Output}{output}

	\caption{Computa corte aproximado}
	\Input{floresta $G = (V,E)$ com $n$ vértices, $m \in [n]$, 
	$c\in (\frac{1}{2}, 1)$}
	\Output{Um corte $(B,W)$ tal que $cm\le|B|\le m$}
	$B \gets \emptyset$\;
	\eIf{$c\le \frac{1}{2}$}{
		Encontrar um corte $(B',W')$ em $G$ com $\frac{m}{2} <|B'| \le m$ 
		(usando o Lema 2)\;
		
		$B \gets B'$\;
	}
	{
		\While{$|B|<cm$}{
			Encontrar um corte $(B',W')$ em $G[V-B]$ com 
			$\frac{m-|B|}{2} <|B'| \le m-|B|$ (usando o Lema 2)\;

			$B \gets B\cup B'$\;		
		}
	}
	\Return $(B,V-B)$

\end{algorithm}	

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%  SEÇÃO 7     %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section {Rotulação dos vértices da árvore 7}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%  SEÇÃO 8     %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section {Algoritmo da dobra do diâmetro 8}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%  SEÇÃO 9     %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section {Algoritmo FST para bissecção 9}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%  SEÇÃO 10    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section {Complexidade do problema da bissecção 10}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%  SEÇÃO 11    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section {Algoritmo de Jansen 11}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%  SEÇÃO 12    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section {Geração de árvores binárias aleatórias 12}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%  SEÇÃO 13    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section {Experimentos computacionais 13}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%  SEÇÃO 14    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section {Conclusoes 14}



\newpage
\bibliographystyle{plain}
\bibliography{refs}
\end{document}
