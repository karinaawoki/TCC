\documentclass[a4paper,12pt]{article}

% Para usar a linguagem PT-BR.
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{tikz}
\usepackage{xcolor}
\usepackage{array}
\usepackage[brazilian]{babel}
\usepackage[linesnumbered,ruled]{algorithm2e}
\usepackage{amsmath, amsthm, amssymb}
\usepackage{mathtools,booktabs}
\usepackage{colortbl}
\usepackage{multirow}

\DeclarePairedDelimiter\ceil{\lceil}{\rceil}

\usetikzlibrary{shapes.geometric,arrows,fit,matrix,positioning}
\tikzset
{
    subtree/.style  = {isosceles triangle, draw=black, 
    align=center, minimum height=0.5cm, minimum width=1cm, shape 
    border rotate=90, anchor=north, fill=red!30}
}

\selectlanguage{brazilian} 

\newtheorem{teo}{Teorema}
\newtheorem{lem}{Lema}
\newtheorem{prov}{Prova}
\newtheorem{alg}{Análise do algoritmo}
\newtheorem{prob}{Problema}

\newcommand{\Oh}{\mathrm{O}}
\newcommand\mycommfont[1]{\footnotesize\ttfamily\textcolor{blue}
{#1}}
\SetCommentSty{mycommfont}


\sloppy

\begin{document}
 
\begin{center}
   {\large \textbf{UNIVERSIDADE DE SÃO PAULO}} \\[1.4cm]
   
   {\large \textbf{INSTITUTO DE MATEMÁTICA E ESTATÍSTICA}}\\[4.2cm]
   
   {\Huge TRABALHO DE CONCLUSÃO }\\[0.3cm]
   {\Huge DE CURSO }\\[9cm]
   
   {\large { Aluna: Karina Suemi Awoki}}\\[0.3cm]
   
   {\large { Orientadora: Cristina Gomes Fernandes}}
   

\end{center}

\newpage
\tableofcontents

\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%  INTRODUÇÃO  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Introdução}

O assunto abordado no Trabalho de Conclusão de Curso se
enquadra na área de Otimização Combinatória e diz respeito ao 
\emph{Problema da Bissecção Mínima}. Para definir o problema 
precisamente, seguem primeiro algumas definições. 

Seja~$G=(V,E)$ um grafo e~$B$ e~$W$ conjuntos de vértices de~$G$,
dizemos que~$(B,W)$ é um \textbf{corte}
de~$G$ se~$B \cup~W =~V(G)$ e~$B\cap~W =~\emptyset$.
Denotamos o número de arestas no corte~$(B,W)$ por \textbf{largura}
do corte ou por~$e_G(B,W)$.
O corte~$(B,W)$ é uma \textbf{bissecção} se~$|B| =~|W|$
quando~$|V|$ é par, ou se~$||B|-~|W|| =~1$ quando~$|V|$ é ímpar.

O \emph{Problema da Bissecção Mínima} consiste em, dado um grafo, 
encontrar uma bissecção no grafo de largura mínima.

Sabe-se que o problema da bissecção é NP-difícil~\cite{GareyJS76} 
e a melhor aproximação conhecida para o caso geral do problema tem 
razão~$\Oh(\lg n)$~\cite{Racke08}, onde~$n$ é o número de vértices 
do grafo. 
Por outro lado, sabe-se que, para árvores e grafos que de uma 
certa maneira se assemelham a árvores, há um algoritmo polinomial 
de programação dinâmica para encontrar uma bissecção mínima, 
proposto por Jansen, Karpinski, Lingas e 
Seidel~\cite{JansenKLS01}. 

Fernandes, Schmidt e Taraz têm interesse em entender a estrutura 
dos grafos cuja bissecção mínima tem largura grande, de modo a 
desenvolver bons algoritmos de aproximação para o problema ou 
identificar melhor as classes de grafos onde o problema torna-se 
especialmente difícil. 
Para tanto, eles têm feito estudos de certas questões em árvores, 
em grafos que têm uma estrutura semelhante às árvores, e também em 
grafos planares~\cite{FernandesST13,FernandesST15}, para os quais 
a complexidade do problema encontra-se em aberto. 

Vários outros resultados são conhecidos para o Problema da 
Bissecção Mínima, porém este trabalho de conclusão de curso se 
concentrou no estudo do problema em árvores.

\newpage


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%   OBJETIVOS  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Objetivos} 

O principal objetivo deste trabalho foi o estudo, implementação e 
análise de um algoritmo recente, proposto por Fernandes, Schmidt e 
Taraz~\cite{FernandesST13}, para encontrar uma bissecção 
aproximadamente mínima em árvores de grau limitado, denotaremos
esse algoritmo por FST. 
A vantagem deste algoritmo sobre o algoritmo de Jansen et 
al.~\cite{JansenKLS01}, que encontra uma bissecção de largura 
mínima, é que este tem um consumo de tempo linear, enquanto que o 
segundo tem um consumo de tempo cúbico no número de vértices da 
árvore. 
Implementamos também o algoritmo de Jansen et al., para fins de 
comparação da largura das bissecções produzidas pelo algoritmo
FST. 

Como já mencionado, o algoritmo de Jansen et al.\ baseia-se em 
programação dinâmica. 
Já o algoritmo de Fernandes et al., para atingir um consumo 
linear, utiliza técnicas bem conhecidas de percursos de árvore, 
como busca em profundidade, bem como um rastreamento de 
informações mais cuidadoso que permite que o processamento todo 
seja executado em tempo linear. 
É um algoritmo mais refinado, dividido na implementação de uma 
série de etapas menores. 

Uma vez implementados os dois algoritmos, foi feita uma análise 
da sua performance em árvores binárias geradas aleatoriamente, e 
em árvores ternárias.
Obtivemos instâncias reais de um problema relacionado e as 
utilizamos também no estudo experimental do algoritmo implementado.
 

\newpage


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%  MÉTODO  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Método}

O estudo do algoritmo de Fernandes et al.\ seguiu um roteiro de
como a implementação foi feita, conforme a proposta do TCC. 
A linguagem escolhida para a implementação foi \texttt{C} e os 
algoritmos implementados foram colocados na página do gitHub. 
O roteiro consistiu em uma divisão da implementação do algoritmo 
em várias etapas, que permitiu um melhor acompanhamento do 
trabalho desenvolvido, e uma organização da forma de estudo. 
O algoritmo encontra-se descrito em um documento 
longo~\cite{Schmidt15} juntamente com a sua análise teórica. 
Este documento serviu como base para o entendimento de cada 
etapa, e de como a implementação de cada etapa deveria ser feita 
para que a implementação obtida fosse de fato linear. 

Reuniões frequentes foram feitas junto à supervisora para 
apresentar as etapas já implementadas, bem como para tirar dúvidas 
sobre as próximas etapas ou detalhes da implementação. 
Em maio e junho, Tina Schmidt, uma das autoras do algoritmo que 
foi implementado, visitou o IME, e a parte da 
implementação que estava pronta foi apresentada a ela, e 
algumas discussões foram feitas e em especial, a Tina conseguiu
um conjunto de instâncias reais com~\cite{Kampmeier} para usarmos 
em nossos experimentos.   

Em paralelo ao estudo e desenvolvimento da implementação, foram 
estudados também dois artigos da literatura. São eles o artigo 
de Garey, 
Johnson e Stockmeyer~\cite{GareyJS76}, que contém a prova de que o 
problema é NP-difícil, e o artigo de Jansen et al., que apresenta 
o algoritmo de programação dinâmica para o problema em árvores. 
Após a implementação do algoritmo de Fernandes et~al., foi feita 
a implementação do algoritmo de Jansen et~al.\ e a comparação dos 
dois. 

\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%  DEFINIÇÕES  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Definições}
	
	\subsection{Conjunto~$[n]$}
	Denotemos por~$\{1,2,\ldots~n\}$
	o conjunto~$[n]$ .

	\subsection{Conjunto de vértices e arestas}
	Para um grafo~$G$, denotamos seu
	conjunto de vértices por~$V(G)$ e seu
	conjunto de arestas por~$E(G)$.

	\subsection{Grau de vértices}
	Em um grafo~$G$, o número de arestas que incidem em um 
	determinado vértice~$v$ é chamado de 
	\textbf{grau} de~$v$ e será representado
	por~$grau_G(v)$. O 
	\textbf{grau máximo}, que é o grau de um vértice de
	maior grau em~$G$, será representado por~$\Delta(G)$.

	\subsection{Caminhos em árvores}
	Um \textbf{caminho} em uma árvore~$T$, de 
	comprimento~$p$, é uma sequência de 
	vértices~$v_0, v_1, \ldots,v_{p-1}, v_p$ 
	onde~$v_{k-1}, v_k$ é uma aresta para todo~$k =~1,2, \ldots, 
	p$. 
	Como existe um único caminho que conecta quaisquer dois 
	vértices~$v_0$ e~$v_p$ em~$T$, chamaremos tal caminho em~$T$ 
	de~$v_0$,$v_p$-\textbf{caminho}.

	\subsection{Distâncias entre vértices}
	A \textbf{distância} entre dois vértices~$a$ e~$b$ de~$T$ é 
	representada por~$dist(a,b)$, e é igual ao comprimento 
	do~$a$,$b$-caminho em~$T$.

		

\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%  SEÇÃO 5     %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Caminho máximo em árvores}
\label{sec:caminhoMaximo}
	\subsection{Algoritmo que encontra um caminho máximo}

	Um \textbf{caminho máximo} em uma árvore~$T$ é um caminho 
	em~$T$ de comprimento máximo.

	Encontrar um caminho máximo em uma árvore~$T=(V,E)$ é uma 
	tarefa computacionalmente simples que pode ser realizada em 
	tempo~$O(n)$, sendo~$n$ o número de vértices de~$T$, ou 
	seja,~$n =~|V|$. 
	Primeiramente escolhe-se um vértice arbitrário~$v \in~V$ e 
	encontra-se um vértice~$y_0$ mais distante de~$v$.
	Depois, repetimos o mesmo processo a partir de~$y_0$, 
	encontrando um vértice~$x_0$ mais distante de~$y_0$. 
	Para encontrar um vértice mais distante de algum vértice dado, 
	basta usar uma busca em largura.  
	Feito isso, temos um caminho máximo em~$T$: o único caminho
	que liga~$x_0$ a~$y_0$.

	\bigskip

	\subsection{Prova de funcionalidade do algoritmo}

	\begin{lem}
	\label{lema:caminhoMax}
		O~$x_0$,$y_0$-caminho é um caminho máximo em~$T$.
	\end{lem}

	\bigskip

	\begin{proof}
		Suponhamos que exista um outro caminho mais longo que 
		o~$x_0$,$y_0$-caminho e sejam~$x$ e~$y$ os seus extremos.

		\begin{itemize}
	        \item \textbf{Caso 1:} O~$x$,$y$-caminho e 
	        o~$x_0$,$y_0$-caminho não possuem vértices em comum.

	        Existe um~$a$,$b$-caminho, de 
	        comprimento~$c \ge 1$, que conecta os dois caminhos, 
	        possuindo assim apenas o vértice~$a$ 
	        no ~$x$,$y$-caminho e apenas o vértice~$b$ 
	        no~$x_0$,$y_0$-caminho.

	        \begin{center} \begin{tikzpicture}
				[scale=.8,auto=left,every node/.style={circle, 
				draw=black,
				fill=blue!20}]
				\node (x) at (0,5)  {$x$};
				\node (y) at (12,5) {$y$};
				\node (a) at (6,4)  {$a$};
				  
				\node (x0) at (0,0) {$x_0$};
				\node (y0) at (12,0) {$y_0$};
				\node (b)  at (6,1)  {$b$};

				\node (n1) at (3,4.5) {...}; %entre x e a 
				\node (n2) at (9,4.5) {...}; %entre a e y
				\node (n3) at (3,0.5) {...}; %entre x0 e b
				\node (n4) at (9,0.5) {...}; %entre y0 e b
				\node (n5) at (6,2.5) {...}; %entre a e b

				\foreach \from/\to in {x/n1,n1/a,a/n2,n2/y,x0/n3,
				n3/b,b/n4,n4/y0,a/n5,b/n5}
				\draw (\from) -- (\to);
			\end{tikzpicture} \end{center}


	        Portanto, temos 
	        que~$ dist(x,y) =~dist(x,a) +~dist(a,y)$ 
	        e~$ dist(x_0,y_0) =~dist(x_0,b) +~dist(b,y_0)$.

	        Como o~$x$,$y$-caminho é 
	        máximo,~$dist(x,y)\ge dist(x_0,y)$,
	        e isso implica que~$dist(x,a)\ge dist(x_0,b)+c$.

	        Como~$x_0$ é um vértice mais distante de~$y_0$, temos 
	        que~$dist(x_0,y_0)\ge~dist(x,y_0)$, que implica 
	        que~$dist(x_0,b)\ge~dist(x,a)+~c$.
	        Logo temos 
	        que~$dist(x,a)\ge~dist(x, a)+2c$,
	        uma contradição, visto que~$c\ge 1$.


			\bigskip
			\bigskip
			\bigskip


			\item \textbf{Caso 2:} O~$x$,$y$-caminho e 
			o~$x_0$,$y_0$-caminho possuem vértices em comum.

			A interseção entre esses dois caminhos é 
			um~$a$,$b$-caminho de comprimento~$c \ge 0$.
			Podemos assumir, sem perda de generalidade, 
			que~$dist(x,a) \le~dist(x,b)$ e 
			que~$dist(x_0,a) \le~dist(x_0,b)$, como na figura 
			abaixo.
			(Do contrário troque~$a$ por~$b$ e possivelmente~$x$
			por~$y$.)

			\begin{center} \begin{tikzpicture}
				[scale=.8,auto=left,every node/.style={circle, 
				draw=black,
				fill=blue!20}]
				\node (x) at (0,4)  {$x$};
				\node (y) at (12,4) {$y$};
				\node (a) at (4,4)  {$a$};
				\node (b) at (8,4)  {$b$};
				\node (x0) at (1.5,6)  {$x_0$};
				\node (y0) at (10.5,2)  {$y_0$};
				  
				\node (n1) at (2,4) {...};
				\node (n2) at (6,4) {...};
				\node (n3) at (10,4) {...};
				\node (n4) at (9.25,3) {...};
				\node (n5) at (2.75,5) {...};

				\foreach \from/\to in {x/n1,n1/a,a/n2,n2/b,b/n3,
				n3/y, a/n5,n5/x0,b/n4,n4/y0}
				\draw (\from) -- (\to);
			\end{tikzpicture} \end{center}


			Como~$x_0$ é um vértice mais distante de~$y_0$,
			temos que~$dist(x_0,a)\ge~dist(x,a)$.
			Por outro lado, como~$x$ é um vértice mais distante
			de~$y$, temos também que~$dist(x,a)\ge dist(x_0,a)$,
			e, portanto,~$dist(x_0,a) =~dist(x,a)$.
			Similarmente, como~$y$ é um vértice mais distante 
			de~$x$, vale que~$dist(y,b) \ge dist(y_0,b)$.

			Agora consideremos o vértice~$v$ que foi escolhido 
			arbitrariamente no início do algoritmo, e seja~$v'$
			o vértice mais próximo de~$v$ no~$x_0$,$y_0$-caminho.
			Se~$v'\ne b$, então, como~$y_0$ é um vértice mais 
			distante de~$v$,
			\begin{align}
				dist(v',y_0) &\ge dist(v',y) =~dist(v',b) + 
				dist(b,y)\nonumber \\
				&\ge dist(v',b) + dist(b,y_0) \ge dist(v',y_0) 
				\nonumber,
			\end{align} 
			o que implica que~$dist(v',y_0)~=~dist(v',y)$ assim
			como~$ dist(b,y)~=~dist(b,y_0)$. 
			Ou seja,~$dist(x,y) =~dist(x_0,y_0)$.
			Resta analisar o caso em que~$v'=b$ (é um caso 
			especial, dado que pode-se ter arestas em comum 
			entre~$v$,$v'$-caminho e o~$y$,$b$-caminho).
			Como~$y$ é um vértice mais distante de~$x$, temos 
			que~$dist(v',y_0) \le~dist(v',y)$.
			Como~$x_0$ é um vértice mais distante de~$y_0$, temos
			que~$dist(x_0,v') \ge dist(y,v')$.
			
			Finalmente, como~$y_0$ é um vértice mais distante 
			de~$v$, vale que~$dist(y_0,v')\ge dist(x_0,v')$.

			Dessas três desigualdades, concluímos 
			que~$dist(y_0,v')~=~dist(y,v')~=
			~dist(x_0,v')~=~dist(x,v')$,
			onde a última igualdade vale pois já mostramos 
			que~$dist(x_0,a) =~dist(x,a)$.

			Assim sendo~$dist(x_0,y_0) =~dist(x,y)$, completando a 
			prova.

		\end{itemize}
	\end{proof}

	\bigskip
	\bigskip


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\subsection{Diâmetro de um Grafo}
	\label{subsec:diametro}
	Dizemos que o \textbf{diâmetro} de um grafo conexo~$G$ é o
	comprimento de um caminho máximo de~$G$. 
	Em outras palavras, o diâmetro pode ser definido como:
	$$ diam(G)=\max\{dist(x,y):x,y\in~V(G)\}.$$

	\bigskip

	Seja~$G$ um grafo não necessariamente conexo,
	o \textbf{diâmetro relativo} de~$G$
	 é a razão entre o número
	de vértices de um caminho máximo e o número total de vértices
	de~$G$. Este pode também ser representado por
	$$ diam^*(G) =~\dfrac{\displaystyle\sum_{
	G'~componente~conexa~de~G}^{}(diam(G')+1)}{|V(G)|}.$$

	\medskip

	Nota-se que para todo grafo~$G$ com~$V(G)\ne \emptyset$, temos
	que~$0<~diam^*(G)\le~1$, pois haverá no mínimo um vértice 
	de~$G$ no caminho máximo, e no máximo, todos os vértices 
	de~$G$.
    
\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%  SEÇÃO 6     %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section {Lemas de cortes aproximados}

Em \cite{Schmidt15}, são apresentados três lemas e seus
respectivos algoritmos, que, dada uma floresta~$G$ e um 
inteiro~$0<m\le~n$, onde~$n$ é o número de vértices de~$G$, 
produzem cortes com algumas propriedades.

Abaixo reproduzimos os três resultados de \cite{Schmidt15} que 
atestam as propriedades dos cortes produzidos por estes algoritmos:

\bigskip
\bigskip
\bigskip

\subsection{Lema do corte aproximado simples para árvores}
\begin{lem}[]
\label{lema:simpleApproxCutTree}
	Para toda árvore~$T$ com~$n$ vértices e todo~$m \in~[n]$,
	existe um corte~$(B,W)$ em~$T$ tal 
	que~$\dfrac{m}{2} <|B| \le~m$ e~$e_T(B,W) \le~\Delta(T)$.
	Um corte que satisfaz esses requisitos pode ser computado em
	tempo~$O(n)$.
\end{lem}

\bigskip

Seja~$T$ uma árvore e~$r$ um vértice de~$T$. 
Assumiremos que
a função~CALCULA\_NUMERO\_DE\_DESCENDENTES$(T,r)$ devolve um vetor
que associa cada vértice de~$T$ ao número de descendentes desse 
vértice na árvore~$T$, enraizada em~$r$. Nota-se que essa função 
pode ser executada usando uma busca em profundidade e toma 
tempo~$O(n)$.


Segue o algoritmo que encontra um corte com as propriedades 
descritas no lema.

\medskip

\begin{algorithm}[H]
\label{alg:simpleApproxCutTree}
	\SetKwInOut{Input}{input}
	\SetKwInOut{Output}{output}

	\caption{Computa corte aproximado em uma árvore}
	\Input{árvore~$T =~(V,E)$ com~$n$ vértices, ~$m \in~[n]$ e 
	uma raíz $r$}
	\Output{Um corte~$(B,W)$ tal que~$\dfrac{m}{2}<|B|\le~m$}
	$B \gets \emptyset$\;
	\eIf{$m =~n$}{
		$B \gets V$\;
	}
	{
		$d \gets~$ CALCULA\_NUMERO\_DE\_DESCENDENTES$(T$, $r)$\;
		$v \gets r$\;
		\While{existe descendente~$u$ de~$v$ com~$d[u]\ge m$ }{
			$v \gets u$ \;
		}
		\eIf{existe descendente~$u$ de~$v$ com~$d[u]>\dfrac{m}{2}$}
		{
			$B\gets T_u$\;  
			\tcp{$T_u$ é a sub-árvore enraizada em~$u$}
		}
		{
		\For{cada filho~$u$ de~$v$}
		{
			\eIf{$|B+T_u| \le~m$}{
				$B\gets B\cup~T_u$\;
			}
			{
				break\;
			}
		}
		}
	}
	\Return $(B,V\setminus B)$

\end{algorithm}	

\bigskip
\bigskip
\bigskip

\textbf{Análise do Algoritmo}

	Suponha que~$T=(V,E)$.
	É fácil ver que se~$m=n$, então os valores~$B =~V$ 
	e~$W =~\emptyset$ satisfazem as condições do lema, dado 
	que~$e_G(B,W)$ será~$0$. 
	Isso pode ser computado em tempo~$O(n)$.

	Caso contrário, é necessário escolher uma raiz arbitrária~$r$ 
	para~$T$ e calcular o número de vértices das sub-árvores 
	enraizadas em cada um dos nós, que é o número de descendentes 
	do nó.
	Isso serve para que saibamos a quantidade de vértices das 
	sub-árvores sem que precisemos percorrer todos os nós das 
	sub-árvores a cada consulta.

	Feito isso, temos que~$v$ é o vértice analisado no momento 
	e~$V_1, V_2, \ldots, V_k$ são as sub-árvores enraizadas 
	nos~$k$ filhos de~$v$.
	Se algum~$V_i$ satisfizer~$\dfrac{m}{2}<~|V_i|\le~m$, podemos 
	retornar a sub-árvore~$|V_i|$ como sendo o conjunto~$B$, 
	satisfazendo o Lema~\ref{lema:simpleApproxCutTree}, dado que o 
	corte será~$1$.
	Caso contrário, se~$|V_i|>~m$ para algum~$i$, assumimos 
	que~$v$ agora é a raiz de~$V_i$ e aplicamos novamente esse 
	processo em~$v$.

	Nota-se que esse procedimento irá parar em algum momento, dado 
	que a árvore é finita, e ele parará quando encontrar uma 
	sub-árvore que satisfaça o Lema~\ref{lema:simpleApproxCutTree}
	(e essa sub-árvore será o conjunto~$B$) 
	ou quando chegarmos numa situação em 
	que~$|V_i|\le~\dfrac{m}{2}$ para todos os~$k$ filhos de~$v$.
	Nesse último caso, sabemos 
	que~$|V_1\cup~V_2\cup~\ldots \cup~V_k|\ge m$, pois
	a sub-árvore enraizada em~$v$ possui mais que~$m$ vértices. 
	Sabemos também que~$|V_i|\le~\dfrac{m}{2}$ para todos os~$k$ 
	filhos de~$v$. 
	Com isso, percorremos os~$V_i$ em ordem, e 
	adicionamos~$V_i$ ao conjunto~$B$, parando antes 
	que~$|B| >~m$. 
	Isso nos dará~$e_T(B,V\setminus B) <~grau_T(v)\le~\Delta(T)$, 
	o que satisfaz o lema.
	Dado que~$|V_j|\le~\dfrac{m}{2}$ para todo~$j$, sabemos que 
	existe um~$i$ tal 
	que~$\dfrac{m}{2} <~|V_1\cup~V_2 \cup~\cdots \cup~V_i| \le~m$, 
	pois a união das sub-árvores enraizadas em~$v$ possui mais 
	que~$m$ vértices e, para todo~$\ell$ que 
	satisfaça~$|V_1\cup~V_2\cup~\cdots\cup~V_\ell|\le~
	\dfrac{m}{2}$, temos 
	que~$|V_1\cup~V_2\cup~\cdots~\cup~V_\ell\cup~V_{\ell+1}|\le~m$.


\bigskip
\bigskip
\bigskip

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%% LEMA 3 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Lema do corte aproximado simples para florestas}

\begin{lem}[{\cite[Lemma 2]{Schmidt15}}]
\label{lema:simpleApproxCutForest}
	Para toda floresta~$G$ com~$n$ vértices e todo~$m \in~[n]$,
	existe um corte~$(B,W)$ em~$G$ tal 
	que~$\dfrac{m}{2} <|B| \le~m$ e~$e_G(B,W) \le~\Delta(G)$.
	Um corte que satisfaz esses requisitos pode ser computado em
	tempo~$O(n)$.
\end{lem}

\bigskip

Agora examinaremos como computar o corte descrito pelo lema.
Nota-se que essa é uma adaptação do algoritmo anterior, 
trocando árvore por floresta.

\medskip
\medskip

\begin{algorithm}[H]
\label{alg:simpleApproxCutForest}
	\SetKwInOut{Input}{input}
	\SetKwInOut{Output}{output}

	\caption{Computa corte aproximado simples em uma floresta}
	\Input{floresta~$G =~(V,E)$ com~$n$ vértices e~$m \in~[n]$}
	\Output{corte~$(B,W)$ tal que~$\dfrac{m}{2}\le|B|\le~m$}
	$B \gets \emptyset$\;
	Sejam~$V_1, V_2,\ldots, V_k$ os conjuntos de vértices das
	componentes conexas de~$G$\;
	\For{$i=1 \to k$}{
		\If{$|V_i| + |B|\le~m$}{
			~$B \gets B\cup~V_i$\;
		}	
		\ElseIf{$|B|<m$}{
			$(B',W')\gets Algoritmo\ref{alg:simpleApproxCutTree}(
			G[V_i], |V_i|, m-|B|)$\;
			\tcp {Devolve o corte~$(B',W')$ em~$G[V_i]$ com 
			$\dfrac{m-|B|}{2} <|B'| \le~m-|B|$ (usando o Lema 
			\ref{lema:simpleApproxCutTree})}

			$B \gets B\cup~B'$\;

			break\;
		}	
	}
	\Return $(B,V\setminus B)$\;

\end{algorithm}	

\bigskip
\bigskip
\bigskip

\textbf{Análise do Algoritmo}

	Temos que~$T_1, T_2, \ldots,T_k$ são 
	as árvores de~$G$. 
	Primeiro percorremos as árvores na ordem que compõem. 
	Seja~$\ell$ o maior inteiro tal 
	que~$s=~\displaystyle\sum_{i=1}^{\ell}|V(T_i)| \le~m$.
	Colocamos~$T_1,T_2, \ldots,T_\ell$ no conjunto~$B$.
	Caso~$s=m$, temos~$|B|=m$ com~$e_G(B,V\setminus B)=0$, o que 
	satisfaz o lema.
	Caso contrário, ao encontrar um corte~$(B',W')$ em~$T_{\ell+1}$
	que satisfaça~$\dfrac{m-s}{2}<|B'|\le~m-s$ 
	com~$e_{T_{\ell+1}}(B',W') \le~\Delta(T_{\ell+1})$, e 
	acrescentar~$B'$ ao conjunto~$B$, 
	teremos~$\dfrac{m+s}{2}<|B| \le~m$ 
	com~$e_G(B,W)=\Delta(T_{\ell+1}) \le~\Delta(G)$.
	Logo, depois de acrescentar~$B'$ em~$B$, teremos o 
	corte~$(B,V\setminus B)$ que satisfaz o lema, e podemos fazer 
	isso utilizando o Lema~\ref{lema:simpleApproxCutTree}.
	
	Nota-se que, como a linha 2 pode ser feita usando uma busca em 
	profundidade e as demais linhas envolvem verificar o tamanho 
	das componentes (que já foi calculado na linha 2) e uma 
	chamada ao Algoritmo~\ref{alg:simpleApproxCutTree}, então essa 
	operação pode ser feita em tempo~$O(n)$, dado que todas as 
	operações citadas são executadas em tempo linear. 

\bigskip
\bigskip
\bigskip


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%% LEMA 4 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Lema do corte aproximado}

\begin{lem}[{\cite[Lemma 3]{Schmidt15}}]
\label{lema:approxCutForest}
	Para toda floresta~$G$ com~$n$ vértices, todo~$m \in~[n]$ e 
	todo~$c \in~[0,1)$, existe um corte~$(B,W)$ em~$G$ tal 
	que~$cm \le~|B| \le~m$ 
	e~$e_G(B,W) \le~\ceil[\Big]{ \dfrac{2c}{1-c}} \Delta(G)$.
	Um corte que satisfaz esses requisitos pode ser computado em
	tempo~$O\Big(\ceil[\Big]{ \dfrac{2c}{1-c}} n\Big)$.
\end{lem}

\medskip
\medskip

\begin{algorithm}[H]
\label{alg:approxCutForest}
	\SetKwInOut{Input}{input}
	\SetKwInOut{Output}{output}

	\caption{Computa corte aproximado em uma floresta}
	\Input{floresta~$G =~(V,E)$ com~$n$ vértices,~$m \in~[n]$, 
	$c\in~(\dfrac{1}{2}, 1)$}
	\Output{Um corte~$(B,W)$ tal que~$cm\le|B|\le~m$}
	\eIf{$c\le~\dfrac{1}{2}$}{
		$(B,W) \gets$ Algoritmo~\ref{alg:simpleApproxCutForest}$(
		G, n, m)$ \;
		\tcp{Devolve o corte~$(B,W)$ em~$G$ com 
		$\dfrac{m}{2} <|B'| \le~m$ (usando o Lema 
		\ref{lema:simpleApproxCutForest})}
		
		$B \gets B'$\;
	}
	{
		$B \gets \emptyset$\;
		\While{$|B|<cm$}{
			$(B',W') \gets$ 
			Algoritmo\ref{alg:simpleApproxCutForest}$(
			G[V\setminus B], n-|B|, m-|B|)$ \;
			\tcp{Devolve o corte~$(B',W')$ em~$G[V\setminus B]$ 
			com $\dfrac{m-|B|}{2} <|B'| \le~m-|B|$ 
			(usando o Lema \ref{lema:simpleApproxCutForest})}

			$B \gets B\cup~B'$\;		
		}
	}
	\Return $(B,V\setminus B)$

\end{algorithm}	

\bigskip
\bigskip
\bigskip

\textbf{Análise do Algoritmo}

	Sabemos que se~$c \le~\dfrac{1}{2}$, podemos aplicar o 
	Algoritmo~\ref{alg:simpleApproxCutForest}, dado que o 
	resultado nos dará um conjunto~$B'$ tal 
	que~$|B'|>\dfrac{m}{2}\ge cm$ e~$e_G(B,W)\le~\Delta(G)$.

	Caso contrário, temos que~$B =~\emptyset$.
	Executaremos o Algoritmo~\ref{alg:simpleApproxCutForest}, 
	referente ao Lema~\ref{lema:simpleApproxCutForest} diversas 
	vezes para encontrar um corte~$(B',W')$ em~$G[V\setminus B]$ 
	tal que~$\dfrac{m-|B|}{2}<|B'|\le~m-|B|$, acrescentando o 
	conjunto~$B'$ a~$B$ em cada uma das chamadas ao 
	Lema~\ref{lema:simpleApproxCutForest}.
	Fazemos isso até que~$|B|\ge cm$ seja satisfeito.
	Nota-se que em algum momento~$|B|\ge cm$ irá ocorrer, pois a 
	cada vez que executamos o 
	Algoritmo~\ref{alg:simpleApproxCutForest}, acrescentamos pelo 
	menos um vértice em~$B$, e~$|B|>m$ nunca irá ocorrer, pois o 
	conjunto~$B'$ obtido no Lema~\ref{lema:simpleApproxCutForest} 
	é tal que~$|B'|\le~m-|B|$. Logo, serão adicionados no 
	máximo~$m-|B|$ vértices em~$B$.

	Verificaremos agora se o consumo de tempo e a largura do corte
	devolvido pelo Algoritmo~\ref{alg:approxCutForest} satisfazem
	o que foi proposto no Lema~\ref{lema:approxCutForest}.
	
	Caso~$c\le~\dfrac{1}{2}$, executamos o
	Algoritmo~\ref{alg:simpleApproxCutForest} uma única vez, 
	portanto o tempo é~$O(n)$, que equivale 
	a~$O(\ceil[\Big]{\dfrac{2c}{1-c}} n)$.
	Em relação a largura do corte, será devolvido o corte do 
	Algoritmo~\ref{alg:simpleApproxCutForest} sem nenhuma 
	modificação, então, sabe-se que~$e_G(B,W)\le~\Delta(G)$.
	Provaremos agora 
	que~$\Delta(G) \le \ceil[\Big]{ \dfrac{2c}{1-c}}\Delta(G)$.
	Como~$0<c<1$, temos que~$0<1-c$ e~$0<2c$, implicando  
	em~$0<~\dfrac{2c}{1-c}$, assim 
	sendo,~$1\le \ceil[\Big]{ \dfrac{2c}{1-c}}$.
	Portanto, como~$\Delta(G)\ge 0$, então temos 
	que~$\Delta(G)\le~\ceil[\Big]{\dfrac{2c}{1-c}}\Delta(G)$, 
	satisfazendo assim as propriedades do 
	Lema~\ref{lema:approxCutForest}.

	Caso contrário,~$c>\dfrac{1}{2}$. Como em todas as vezes que
	executamos a linha 7 do Algoritmo~\ref{alg:approxCutForest}, 
	vale que~$|B|<cm$, então também é válido que~$m-|B|>~(1-~c)m$.
	E como~$m-|B|$ é o valor do~$m$ que passaremos para o 
	Algoritmo~\ref{alg:simpleApproxCutForest}, sabemos que o 
	conjunto $B$ do corte devolvido terá mais 
	que~$\dfrac{m-|B|}{2}$ vértices.
	Portanto, executaremos o 
	Algoritmo~\ref{alg:simpleApproxCutForest} no 
	máximo~$\ceil[\Big]{\dfrac{cm}{\dfrac{(1-c)m}{2}}} 
	=~\ceil[\Big]{\dfrac{2c}{1-c}}$ vezes, dando, no total, um
	tempo~$O(\ceil[\Big]{ \dfrac{2c}{1-c}} n)$.
	Usaremos essa mesma linha de pensamento para calcular o largura
	máxima do corte devolvido. Sabemos que o 
	Algoritmo~\ref{alg:simpleApproxCutForest} será 
	chamado~$\ceil[\Big]{\dfrac{2c}{1-c}}$ vezes, e para cada uma 
	das vezes ele devolve um corte cuja largura 
	máxima é~$\Delta(G)$, portanto, a largura máxima do corte 
	devolvido é~$\ceil[\Big]{\dfrac{2c}{1-c}}\Delta(G)$.







%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%  SEÇÃO 7     %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage

\section {Rotulação dos vértices da árvore}

	Mais adiante, iremos nos referir a vértices com uma 
	característica específica, e para isso precisamos atribuir um 
	rótulo numérico~$x\in~[n]$ distinto para cada um dos vértices 
	da árvore, onde~$n$ é o número de vértices da árvore~$T$. 
	Denotaremos o \textbf{rótulo} de um vértice~$v$ por~$rot(v)$.

	Primeiramente, usaremos o método mencionado na 
	seção~\ref{sec:caminhoMaximo} paracalcular 
	o~$v_0$-$v_k$-caminho, de comprimento~$p$, que é máximo 
	em~$T$. 
	Para todo vértice~$v\in~V(v_0$-$v_k$-caminho$)$, teremos uma 
	árvore~$T_v \in~G\setminus E(v_0$-$v_k$-caminho$)$ de modo 
	que~$v\in~T_v$.

	Dessa forma, teremos sub-árvores enraizadas nos vértices do
	caminho máximo, como o mostrado na figura abaixo.
	

 	%% fill=blue!30 -- núemro indica quão escuro é
	\begin{center} \begin{tikzpicture}
		[scale=.7,auto=left,every node/.style={circle, draw=black,
				fill=blue!20}]

		\draw [draw=yellow, fill=yellow!20] (0,4.8) 
		ellipse (1.3cm and 2.4cm); %0
		\draw [draw=yellow, fill=yellow!20] (3,4.4) 
		ellipse (1.3cm and 2.4cm); %1
		\draw [draw=yellow, fill=yellow!20] (6,4.8) 
		ellipse (1.3cm and 2.4cm); %2
		\draw [draw=yellow, fill=yellow!20] (9,4.4) 
		ellipse (1.3cm and 2.4cm); %3
 		\draw [draw=yellow, fill=yellow!20] (12,4.8) 
 		ellipse (1.3cm and 2.4cm); %4
		\draw [draw=yellow, fill=yellow!20] (18,4.8) 
		ellipse (1.3cm and 2.4cm); %5

		\node [text=blue!65,draw=none, fill=none] at 
		(-0.4,6.5) {$T_{v_0}$};
		\node [text=blue!65,draw=none, fill=none] at 
		(2.6,6.1) {$T_{v_1}$};
		\node [text=blue!65,draw=none, fill=none] at 
		(5.6,6.5) {$T_{v_2}$};
		\node [text=blue!65,draw=none, fill=none] at 
		(8.6,6.1) {$T_{v_3}$};
		\node [text=blue!65,draw=none, fill=none] at 
		(11.6,6.5) {$T_{v_4}$};
		\node [text=blue!65,draw=none, fill=none] at 
		(17.6,6.5) {$T_{v_p}$};

		\node [subtree] (y1) at (3,4.6)  {};
		\node [subtree, fill=red!30] (y2) at (6,5)  {};
		\node [subtree] (y3) at (9,4.6)  {};
		\node [subtree] (y4) at (12,5) {};

		\node (x0) at (0,5.4)  {$v_0$};
		\node (x1) at (3,5)    {$v_1$};
		\node (x2) at (6,5.4)  {$v_2$};
		\node (x3) at (9,5)    {$v_3$};
		\node (x4) at (12,5.4) {$v_4$};
		\node (x5) at (15,5)   {...};
		\node (x6) at (18,5.4) {$v_p$};


		\foreach \from/\to in {x0/x1,x1/x2,x2/x3,x3/x4,x4/x5,x5/x6}
		\draw (\from) -- (\to);

	\end{tikzpicture} \end{center}

	Temos que cada vértice contido no~$v_0$-$v_p$-caminho receberá 
	uma rotulação de forma que:
	\begin{itemize}
		\item~$rot(v_i)>rot(v_j)$ para todo~$i<j$ e
		\item~$rot(v_{i-1})<~v' \le~rot(v_i)$ para todo 
		vértice~$v'$ contido na sub-árvore enraizada em~$v_i$. 
	\end{itemize}

	\bigskip
	\bigskip

	\subsection{Descrição do algoritmo de rotulação}
	Essa rotulação pode ser obtida facilmente 
	manipulando a lista de adjacência e em seguida,
	usando uma busca em profundidade.
	Ambas as ações são executadas em tempo linear, então
	pode-se rotular uma árvore em tempo~$O(n)$.

	Para cada vértice~$v_i$ contido no~$v_1$-$v_{p}$-caminho, 
	percorremos a sua lista de adjacência e quando encontrarmos o 
	vértice~$v_{i-1}$, colocamos ele no início da lista.
	Dessa forma, quando aplicamos uma busca em profundidade nessa 
	árvore, usando o~$v_p$ como raiz, a busca descerá primeiro
	pelos vértices do caminho máximo e atribuirá a rotulação
	somente quando terminar de ver todos os vértices filhos, 
	garantindo assim que para todo~$r\in~\{1,\ldots, p\}$, temos 
	que~$rot(T_{v_i})\le~rot(v_i)$ e~$rot(v_i)>~rot(v_{i-1})$.
	
	\bigskip
	\bigskip

	\subsection{Mapeamento dos rótulos de vértices }
	Vamos definir agora as funções que mapeiam um vértice em 
	outro, utilizando a rotulação como base.
	Chamaremos de~$map^+_m$ a função que devolve o~$m$-ésimo 
	próximo vértice e, de~$map^-_m$ a função inversa da primeira, 
	sendo assim ela devolve o~$m$-ésimo vértice anterior.
	Dessa forma, podemos ver que, seja~$v$ um 
	vértice, ~$map^+_m(rot(v)) =~(rot(v)+~m)\mod n$ 
	e~$map^-_m(rot(v)) =~(rot(v)-~m)\mod n$.

	Para facilitar, identificaremos os vértices pelos seus 
	rótulos. 
	Sendo assim, temos que para um 
	vértice~$v$, ~$map^+_m(v) =~(v+~m)\mod n$ 
	e~$map^-_m(v) =~(v-~m)\mod n$ como uma simplificação das 
	funções enunciadas anteriormente.

	Nota-se que para todo $m\in~[n]$, caso~$n>2$, se existe 
	um~$v$ tal 
	que~$v\in~v_0$-$v_k$-caminho 
	e~$map^+_m(v)\in~v_0$-$v_k$-caminho, então 
	existe um corte $(B,W)\in~T$, tal 
	que~$B =~\{v+1, v+2,\ldots,~v+m\}$, com~$|B|=~m$
	e~$e_T(B,W)\le~2\le~\Delta(T)$.
	Isso pode ser visto na figura abaixo.

	\begin{center} \begin{tikzpicture}
		[scale=.7,auto=left,every node/.style={circle, draw=black,
				fill=blue!20}]

		\draw [draw=yellow, fill=yellow!20] (7.5,1.5) rectangle 
		(13.5, 6.5);

		\node [text=blue!65,draw=none, fill=none] at 
		(10.5,2.2) {\Large{$m$ vértices}};
		\node [draw=none, fill=none] at 
		(9,6.5) {\footnotesize{$map^+_m$}};
		\node [draw=none, fill=none] at 
		(9,7.9) {\footnotesize{$map^-_m$}};


		\node [subtree] (y1) at (3,4.6)  {};
		\node [subtree, fill=red!30] (y2) at (6,5)  {};
		\node [subtree] (y3) at (9,4.6)  {};
		\node [subtree] (y4) at (12,5) {};

		\node (x0) at (0,5.4)  {$v_0$};
		\node (x1) at (3,5)    {$v_1$};
		\node (x2) at (6,5.4)  {$v_2$};
		\node (x3) at (9,5)    {$v_3$};
		\node (x4) at (12,5.4) {$v_4$};
		\node (x5) at (15,5)   {...};
		\node (x6) at (18,5.4) {$v_p$};


		\foreach \from/\to in {x0/x1,x1/x2,x3/x4,x5/x6}
		\draw (\from) -- (\to);

		\path[-, line width=1.5pt, draw=red]
		(x2) edge[right] (x3);
		\path[-, line width=1.5pt, draw=red]
		(x4) edge[right] (x5);

		\path[->, line width=1.5pt]
		(x2) edge[bend left=23 ] (x4);
		\path[->, line width=1.5pt]
		(x4) edge[bend right=45, looseness=1.7 ] (x2);


	\end{tikzpicture} \end{center}
	
	Caso contrário, ~$n\le~2$. 
	É fácil ver que todos os vértices
	da árvore estarão no caminho máximo, portanto, para
	qualquer~$m\in[n]$, teremos um conjunto~$B$ tal
	que~$|B|=m$
	e~$e_T(B,W)\le~|E(T)|=~n-1=~\Delta(T)\le 2$.


	\newpage
	\subsection{Lema do corte em árvores de caminho longo
	%\color{red}{Esse nome está bom?}
	}

	Futuramente usaremos os resultados do lema abaixo na prova de 
	um dos teoremas.

	\begin{lem}[{\cite[Lemma 5]{Schmidt15}}]
	\label{lema:caminhoLongo}
		Para toda árvore~$T$ com~$n$ 
		vértices,~$diam^*(T)>~\dfrac{1}{2}$
		e para todo~$m\in[n]$, existe um corte~$(B,W)$ em~$T$
		com~$|B|=m$ e~$e_T(B,W)\le~2$. Um corte que satisfaz esses
		requisitos pode ser computado em tempo~$O(n)$.
	\end{lem}

	\medskip
	\medskip

	Podemos ver que a função~$map^+_m(x)$ é injetora, dado que numa
	soma, elementos distintos do domínio tem imagens distintas.

	Uma árvore com a propriedade ~$diam^*(T)>~\dfrac{1}{2}$ é uma
	árvore cujo caminho máximo contém mais que a metade dos 
	vértices da árvore, o que nos leva ao fato de que existem mais 
	vértices no caminho máximo do que fora dele. 

	Como o mostrado anteriormente, se um vértice~$v$ mapeia um
	vértice~$v'$ e ambos estão no caminho máximo, então existe um
	corte~$(B,W)$ em~$T$ com~$e_T(B,W)\le 2$.
	Dado que~$diam^*(T)>\dfrac{1}{2}$, e usando o fato de 
	que~$map^+_m(x)$ é uma função injetora e que
	existem mais vértices no caminho máximo do que fora dele,
	temos que pelo menos um vértice do caminho máximo irá mapear
	outro vértice do caminho máximo. Isso ocorre porque todos
	os vértices mapeiam algum outro vértice, e não temos um 
	número suficiente de vértices fora do caminho máximo para serem
	mapeados por todos os vértices do caminho máximo, então algum
	vértice do caminho máximo vai acabar mapeando outro do caminho
	máximo, e assim, obtemos um corte~$(B,W)$, com~$e_T(B,W)\le 2$,
	como o descrito na subseção anterior.

	Um algoritmo que encontra corte desse tipo, em árvores com 
	essa propriedade, irá percorrer os vértices do caminho máximo
	e verificar se algum deles mapeia um vértice do caminho máximo.
	Isso pode ser feito em tempo~$O(n)$ se for mantido um vetor 
	binário que indica se cada um dos vértices está ou não no
	caminho máximo.

	%{\color{red}{-O algoritmo é bem simples. Não precisa colocar
	%código né?}}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%  SEÇÃO 8     %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section {Algoritmo da dobra do diâmetro}
	
	\subsection{Teorema da dobra do diâmetro}
	
		\begin{teo}[{\cite[Theorem 4]{Schmidt15}}]
		\label{teo:dobraDiametro}
			Para toda árvore~$T$ com~$n\ge 3$ vértices e 
			todo~$m\in [n]$,
			o conjunto de vértices de~$T$ pode ser particionado em 
			três partes~$B$,~$W$ e~$S$ tal que vale um dos 
			seguintes itens:
			\begin{enumerate}
				\item $|B|=m$, $S=\emptyset$, e~$e_T(B,W)\le 2$, ou
				\item $|B|\le m\le |B|+|S|$, 
				com~$0<|S|\le\dfrac{n}{2}$,
				$e_T(B,W,S)\le \dfrac{2\cdot 
				\Delta(T)}{diam^*(T)}$, 
				e~$diam^*(T[S])\ge 2diam^*(T)$.
			\end{enumerate}
			Uma partição~$(B,W,S)$ que satisfaz 1 ou 2 pode ser
			computada em tempo~$O\Big(\dfrac{n}{diam^*(T)}\Big)$ 
		\end{teo}

	\medskip
	\medskip


	\subsection{Algortimo da dobra do diâmetro}
	\begin{algorithm}[H]
	\label{alg:dobraDiametro}
		\SetKwInOut{Input}{input}
		\SetKwInOut{Output}{output}

		\caption{Inserção do nó $n$ na árvore binária de busca}
		\Input{árvore $T$ com $n$ vértices e $m\in[n]$}
		\Output{}

	\end{algorithm}	

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%  SEÇÃO 9     %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section {Algoritmo FST para bissecção}

	\subsection{Teorema do corte exato}
	\begin{lem}
	\label{lem:grauMaximo}
		Para toda árvore~$T$ com~$n>2$ vértices
		e toda aresta~$e=\{v_1,v_2\}$ em~$T$, 
		tal que~$v_1,v_2\in V$ e~$grau_T(v_1)=grau_T(v_2)=1$,
		temos que~$\Delta(T) = \Delta(T\cup e)$.
	\end{lem}
	
	
	\begin{proof}
		Como~$n>2$ vértices, então temos que~$\Delta(T)\ge 2$.
		Sabemos que ao adicionar~$e$ em~$T$, o grau de~$v_1$
		e~$v_2$ passará a ser 2, e os demais vértices não terão
		o grau alterado.
		
		Seja~$v$ um vértice de~$T$ tal 
		que~$grau_T(v) = \Delta(T)\le 2$,
		dado que~$grau_T(v_1)=grau_T(v_2)=1$
		sabe-se que~$v\ne v_1$ e~$v\ne v_2$, o que leva 
		a~$grau_{T\cup e}(v)=grau_T(v)=\Delta(T)$.

		
		Dessa forma, temos que
		\begin{align}
			\Delta(T\cup e) &= \max\{grau_{T\cup e}(v_1), 
			grau_{T\cup e}(v)\}\nonumber\\
         		&= \max\{2, grau_{T\cup e}(v)\} \nonumber\\
				&= grau_{T\cup e}(v) \nonumber\\
         		&= grau_T(v) \nonumber\\
         		&= \Delta(T) \nonumber
		\end{align}		

	\end{proof}

	\bigskip
	\bigskip
	\bigskip

	\begin{teo}[Teorema do corte exato
	{\cite[Theorem 6]{Schmidt15}}]
	\label{teo:corteExato}
		Para todo~$i\in \mathbb{N^+_*}$, toda árvore~$T$ com~$n$
		vértices e~$diam^*(T)>\dfrac{1}{2^i}$, e todo~$m\in[n]$,
		existe um corte~$(B,W)$ em~$T$ com~$|B|=m$ 
		e~$e_T(B,W)\le 4\cdot 2^i\cdot \Delta(T)$.
		Um corte que satisfaz esses requisitos pode ser computado
		em tempo~$O\Big(\dfrac{n}{diam^*(T)}\Big)$.
	\end{teo}

	\medskip
	\medskip

	\begin{proof}
		Utilizaremos indução para provar o 
		Teorema~\ref{teo:corteExato} 
		(não levaremos em conta o tempo de execução agora).
		
		Primeiramente, temos que~$diam^*(T)\le1$, como o mostrado 
		na seção~\ref{subsec:diametro}. 
		Sendo assim, sabe-se que~$i\ge1$, logo~$i=1$ será a base 
		utilizada na indução.
		
		Caso base,~$i=1$.
		Para todo~$n\le 2$, sabe-se que~$|E(T)|=\Delta(T)$, e nesse
		caso,~$e_T(B,W)\le |E(T)|=\Delta(T)\le 4\cdot 2^i\cdot 
		\Delta(T)$.
		Para~$n>2$ temos que~$diam^*(T)>\dfrac{1}{2}$, logo, 
		podemos utilizar o Lema~\ref{lema:caminhoLongo} para obter 
		um corte~$(B,W)$ 
		com~$e_T(B,W)\le 2 < 4\cdot 2^i\cdot \Delta(T)$.
		Portanto, esse teorema é válido para~$i=1$.


		Caso~$i\ge 2$. Provaremos que esse teorema vale para~$i$, 
		assumindo que ele é válido para~$i-1$.
		De modo semelhante ao caso anterior, para~$n\le2$, temos 
		que~$e_T(B,W)\le |E(T)|=\Delta(T)\le 2\cdot 2^i\cdot 
		\Delta(T)$.
		Porém, se~$n>2$, podemos utilizar o 
		Teorema~\ref{teo:dobraDiametro}, que nos devolverá cortes 
		do tipo 1 ou 2.
		\begin{itemize}
			\item Se for do tipo 1, teremos~$|B|=m$ 
			e~$e_T(B,W)\le2\le 2\cdot 2^i\cdot \Delta(T)$.

			\item Se for do tipo 2, podemos obter um 
			corte~$(B',W',S')$
			tal que~$|B'|=m$ ou~$|B'|<m\le |B'|+|S'|$
			com~$e_T(B',W',S')\le \dfrac{2\cdot 
			\Delta(T)}{diam^*(T)}\le
			2\cdot2^i\cdot\Delta(T)$.
			
			Se~$|B'|=m$, temos então as propriedades do corte desse
			teorema.

			Caso contrário,~$|B'|<m\le |B'|+|S'|$, o que nos leva 
			a~$0<m-|B'|\le|S'|$. 
			Pelas propriedades do Teorema~\ref{teo:dobraDiametro}, 
			sabemos que~$diam^*(T[S'])\ge 2\cdot diam^*(T)>
			\dfrac{1}{2^{i-1}}$.
			Como~$0<m-|B'|\le|S'|$ e~$diam^*(T[S'])>
			\dfrac{1}{2^{i-1}}$, podemos usar o 
			Teorema~\ref{teo:corteExato} em~$T[S]$ com~$m$ 
			valendo~$m-|B'|$ e~$i$ valendo~$i-1$.
			
			Porém, existem casos onde o conjunto~$S'$ retornado 
			pelo Teorema~\ref{teo:dobraDiametro} não é conexo, 
			pois, de acordo com o 
			Algoritmo~\ref{alg:dobraDiametro},~$S'$ pode se 
			dividir em duas componentes, uma no começo e outra
			no fim do caminho máximo, como o mostrado na figura 
			abaixo. 


			\begin{center} \begin{tikzpicture}
				[scale=.625,auto=left,
				every node/.style={circle, draw=black,
					fill=blue!20}]

				\draw [draw=blue!65,fill=yellow!20] (-1,1.5) 
				rectangle (7, 6.5);

				\draw [draw=none, fill=yellow!20] (11,4.7) 
				rectangle (19, 6.5);
				\draw [draw=none, fill=yellow!20] (13.5,1.5) 
				rectangle (19, 6.5);

				\node [text=blue!65,draw=none, fill=none] at 
				(0,2.5) {\Large{$S$}};
				\node [text=blue!65,draw=none, fill=none] at 
				(18,2.5) {\Large{$S$}};

				\node [subtree] (y1) at (3,4.6)  {};
				\node [subtree, fill=red!30] (y2) at (6,5)  {};
				\node [subtree] (y3) at (9,4.6)  {};
				\node [subtree] (y4) at (12,5) {};
				\node [subtree] (y5) at (15,4.6) {};

				\node (x0) at (0,5.4)  {$v_0$};
				\node (x1) at (3,5)    {...};
				\node (x2) at (6,5.4)  {$v_i$};
				\node (x3) at (9,5)    {...};
				\node (x4) at (12,5.4) {$v_j$};
				\node (x5) at (15,5)   {...};
				\node (x6) at (18,5.4) {$v_p$};

				\foreach \from/\to in {x0/x1,x1/x2,x2/x3,x3/x4,
				x4/x5,x5/x6}
				\draw (\from) -- (\to);

				% Define the points of a regular pentagon
				\path (13.5,4.7) coordinate (P0);
				\path (11,4.7) coordinate (P1);
				\path (11,6.5) coordinate (P2);
				\path (19,6.5) coordinate (P3);
				\path (19,1.5) coordinate (P4);
				\path (13.5,1.5) coordinate (P5);
				% Draw the edges of the pentagon
				\draw[draw=blue!65] (P0) -- (P1) -- (P2) -- (P3) 
				-- (P4) -- (P5) -- cycle;


			\end{tikzpicture} \end{center}

			Como o Teorema~\ref{teo:corteExato} se trata de 
			árvores, precisamos tornar~$S'$ conexo de forma a não 
			alterar o~$\Delta(T)$.
			Sabemos que se adicionarmos uma aresta~$e$ em~$T$, que 
			liga o primeiro ao último vértice do caminho máximo,
			então~$S'$ será conexo. 
			Diremos que~$T' = T\cup e$.

			Nota-se também que em ambas as componentes de~$S'$, 
			temos que o caminho máximo de cada uma é a interseção 
			entre o caminho máximo de~$T$ e a componente.
			Logo, se adicionando~$e$, teremos um caminho máximo 
			em~$S'$ e preservaremos, em parte, o caminho máximo 
			de~$T$. 
			Além disso, de acordo com o Lema~\ref{lem:grauMaximo}, 
			teremos que~$\Delta(T) = \Delta(T')$, já que~$e$ 
			conectará dois vértices extremos do caminho máximo, 
			que possuem grau um.
			Podemos, então, passar a árvore~$T'[S']$ para o 
			Teorema~\ref{teo:corteExato}, sem nos preocupar com a 
			modificação do grau máximo.
			
			Como assumimos que o Teorema~\ref{teo:corteExato} vale
			para~$i-1$, então existe um corte~$(B'',W'')$
			tal que~$|B''|=m-|B'|$ 
			e~$e_{T[S]}(B'',W'')\le 4\cdot 2^{i-1}\cdot
			\Delta(T'[S'])\le 4\cdot 2^{i-1}\cdot\Delta(T')$.

			Dessa forma, sabemos que existe um corte~$(B,W)$ tal
			que~$B=B'\cup B''$ e~$W=V(T)\setminus B$, sendo 
			que~$|B|=|B'| + m-|B'| = m$ e
			\begin{align}
				e_T(B,W)&\le e_T(B',W',S') + e_{T[S]}(B'',W'') 
				\nonumber\\
				&\le 2\cdot2^i\cdot\Delta(T) + 4\cdot 2^{i-1}\cdot
				\Delta(T')\nonumber\\
				&\le 2\cdot2^i\cdot\Delta(T) + 4\cdot 2^{i-1}\cdot
				\Delta(T)\nonumber\\
				&\le 4\cdot 2^{i}\cdot\Delta(T) \nonumber
			\end{align}
			provando assim que o Teorema~\ref{teo:corteExato} é
			válido para~$i$ partindo do pressuposto de que ele vale
			para~$i-1$. Logo, temos que o 
			Teorema~\ref{teo:corteExato} é válido para 
			todo~$i\in \mathbb{N^+_*}$.
			
		\end{itemize}
	\end{proof}

	\bigskip
	\bigskip
	\bigskip
	\bigskip
	\bigskip

	\subsection{Algoritmo do corte exato}

		Seja~$T=(V,E)$ uma árvore e~$v_1,v_2\in V$.
		% Assumimos que a função INSERE\_ARESTA$(T,v_1,v_2)$ irá 
		% inserir uma aresta em~$T$, ligando os 
		% vértices~$v_1$ e~$v_2$ em tempo constante. 
		Assumimos que a função COMPUTA\_CAMINHO\_MÁXIMO$(T)$ 
		devolve um vetor contendo os vértices do caminho 
		máximo, de acordo com a ordem que aparecem no caminho, 
		isso pode ser feito em tempo~$O(n)$, como o descrito na 
		seção~\ref{sec:caminhoMaximo}.

		% Seja~$vet$ um vetor, temos que as funções PRIMEIRO$(vet)$ 
		% e ULTIMO$(vet)$ devolvem o primeiro e o último elementos 
		% do vetor, respectivamente em tempo constante.

		Segue o algoritmo que encontra um corte que satisfaz as 
		propriedades do Teorema~\ref{teo:corteExato}.
		
		\bigskip
		\bigskip
		\begin{algorithm}[H]
		\label{alg:corteExato}
			\SetKwInOut{Input}{input}
			\SetKwInOut{Output}{outp}

			\caption{Computa corte exato em uma árvore}
			\Input{árvore $T=(V,E)$ com $n$ vértices e $m\in[n]$}
			\Output{corte $(B,W)$ tal que $|B|=m$}
			$B\gets \emptyset$\;
			$S'\gets V$\;
			$raiz\gets$ um vértice arbitrário de~$T$\;
	
			\While{$|B|<m$}
			{
				$P\gets$ COMPUTA\_CAMINHO\_MAXIMO$(T[S'])$\;
				$[(B',W',S'), raiz]\gets$
				Algoritmo\ref{alg:dobraDiametro}$(T[S']$,
				$|S'|$, $m-|B|$, $P$, $raiz)$\;
				$B\gets B\cup B'$\;

				% \If{$T[S']$ não é conexo}
				% {
				% 	INSERE\_ARESTA$(T[S']$, PRIMEIRO$(P)$, 
				% 	ULTIMO$(P))$\;
				% }
			}
			\Return $(B,V\setminus B)$\;

		\end{algorithm}	

		\bigskip
		\bigskip
		\bigskip

		\textbf{Análise do Algoritmo}

		% Sabe-se que calcular um caminho máximo faz parte do
		% Teorema~\ref{teo:dobraDiametro} e deveria estar no
		% Algoritmo~\ref{alg:dobraDiametro}, mas, precisamos 
		%acessar 
		% esse caminho máximo para, possivelmente, acrescentar a 
		% aresta citada na prova do Teorema~\ref{teo:corteExato}, 
		% portanto, encontrar um caminho máximo fará parte do 
		% Algoritmo~\ref{alg:corteExato}.

		No algoritmo, temos que transformar o conjunto de 
		vértices~$S'$ em um grafo. 
		Poderíamos fazer isso verificando todas as arestas que 
		ligam dois vértices de~$S'$ e colocar no grafo, mas podemos
		fazer isso no Algoritmo~\ref{alg:dobraDiametro} de forma 
		mais eficiente. 
		Sabemos que no Algoritmo~\ref{alg:dobraDiametro},
		analisamos os vértices de~$S'$ que se ligam a vértices 
		de~$V(T)\setminus S'$. 
		Portanto, podemos usar uma marcação para indicar que as 
		arestas que ligam~$S'$ e~$V(T)\setminus S$ estão inativas, 
		tornando $S'$ uma componente conexa isolada. 
		Isso pode ser feito em tempo~$O(1)$.
		O Algoritmo~\ref{alg:dobraDiametro} também devolverá 
		algum vértice de~$S'$ que será usado como raiz na 
		próxima interação do Algoritmo~\ref{alg:dobraDiametro}.

		Acrescentar a aresta~$e$, como o descrito no
		Teorema~\ref{teo:corteExato} também pode ser feito de 
		forma mais simples no Algoritmo~\ref{alg:dobraDiametro},
		que assim como 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%  SEÇÃO 10    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section {Complexidade do problema da bissecção}
	Nesta seção veremos duas reduções que provam que o problema 
	da bissecção mínima é NP-Completo, assumindo
	que o problema Max Sat2 é NP-completo.

	Primeiramente, vamos definir alguns problemas para facilitar
	a compreensão das reduções.

	\medskip

	\begin{prob}[Max Sat2 - Satisfatibilidade máxima com no máximo 
	duas literais por cláusula{~\cite{GareyJS76}}]
		Dadas~$p$ cláusulas na forma disjuntiva distintas, com no máximo
		duas literais cada, e um inteiro~$k\le p$,
		encontrar valores para cada uma das literais, de forma
		que~$k$ ou mais variáveis sejam verdadeiras.

		%~$C_i=(x_1 x_2)$,
	\end{prob}

	\medskip

	\begin{prob}[Simple Max Cut - Corte Máximo Simples 
]
		Dado um grafo~$G(V,E)$, onde cada uma das arestas tem 
		peso 1, e um inteiro positivo~$W\le|E|$, encontrar um
		corte~$(T,F)$ em $T$ tal 
		que~$e_G(T,F)\ge~W$.
		
	\end{prob}

	

	% \begin{prob}[Corte mínimo em subconjuntos de mesmo tamanho 
	% {~\cite{GareyJS76}}]
	% 	Dado um grafo~$G(V,E)$, onde cada uma das arestas tem 
	% 	peso 1, e um inteiro positivo~$W\le|E|$, encontrar um
	% 	conjunto de vértices~$S\subseteq V$ tal 
	% 	que~$e_G(S,V\setminus~S)\ge~W$.
		
	% \end{prob}

	\bigskip
	\bigskip
	\bigskip

	\subsection{Redução Max Sat2 para SimpleMaxCut}

		Temos um problema Max Sat2 e precisamos transformar
		a sua solução na solução do problema Simple Max Cut.
		Para isso vamos definir alguns conceitos referentes
		ao problema Max Sat2:
		\begin{itemize}
			\item $p = $ número de cláusulas
			\item $n = $ número de variáveis
		\end{itemize}

		Primeiramente, vamos definir essa redução para depois
		explicar o porquê ela funciona.
		A redução consiste em criar um grafo~$G=(V,E)$, de 
		acordo com uma entrada para o problema Max Sat2.
		Segue o conjunto de vértices e arestas de~$G$, 
		respectivamente.
		
		\begin{align}
			V = &\{x_i: 1\le i\le n\} &\cup \nonumber\\
				&\{\overline{x_i}: 1\le i\le n\} &\cup\nonumber\\ 
				&\{T_j: 0\le j\le 3p\} &\cup \nonumber\\
				&\{F_j: 0\le j\le 3p\} &\cup \nonumber\\
				&\{t_{ij}: 1\le i\le n, 0\le j\le 3p\} 
					&\cup \nonumber\\
				&\{f_{ij}: 1\le i\le n, 0\le j\le 3p\} 
					&\cup \nonumber
		\end{align}

		\begin{align}
			E_1=&\{ \{T_i,F_j\}: 0\le i\le 3p, 0\le j\le 3p\} &\cup 
					\nonumber\\
				&\{\{t_{ij}, f_{ij}\}: 1\le i\le n, 
					0\le j\le 3p\} &\cup \nonumber \\
				&\{\{x_i, f_{ij}\}: 1\le i\le n, 
					0\le j\le 3p\} &\cup \nonumber \\
				&\{\{\overline{x_i}, t_{ij}\}: 1\le 
					i\le n, 0\le j\le 3p\} \nonumber
		\end{align}

		% \begin{align}
		% 	E_1=&\textcolor{blue}{\{ \{T_i,F_j\}: 0\le i\le 
		% 		3p, 0\le j\le 3p\}} &\cup \nonumber\\
		% 		&\textcolor{green!70}{\{\{t_{ij}, f_{ij}\}: 1\le i\le n, 
		% 			0\le j\le 3p\}} &\cup \nonumber \\
		% 		&\textcolor{brown}{\{\{x_i, f_{ij}\}: 1\le i\le n, 
		% 			0\le j\le 3p\}} &\cup \nonumber \\
		% 		&\textcolor{violet}{\{\{\overline{x_i}, t_{ij}\}: 1\le 
		% 			i\le n, 0\le j\le 3p\}} \nonumber \\
		% \end{align}

		E para cada uma das~$p$ cláusulas da forma~$C_i=(a_i\lor b_i)$, 
		temos também as arestas a seguir.

		\begin{align}
			E_2=&\{ \{a_i,b_i\}: 1\le i\le p, a_i\ne b_i \} &\cup 
					\nonumber\\
				&\{\{a_i, F_{2\cdot i-1}\}: 1\le i\le p\} &\cup \nonumber \\
				&\{\{b_i, F_{2\cdot i}\}: 1\le i\le p\} \nonumber
		\end{align}

		Dessa forma, temos o grafo~$G = (V,E)$, com~$E=E_1\cup E_2$.
		Segue abaixo um exemplo de como ficaria~$G$ sendo gerado por
		uma cláusula do tipo~$(x_1\lor \overline{x_2})$.
		As arestas de~$E_2$ estão representadas pela cor 
		\textcolor{red}{\textbf {vermelha}}.

		\bigskip
		\bigskip

		\begin{center} \begin{tikzpicture}
			[scale=.7,auto=left,every node/.style={circle, 
			draw=black,
			fill=blue!20}]
			
			\node (t0) at (4, 13)  {$T_0$};
			\node (t1) at (7, 13)  {$T_1$};
			\node (t2) at (10,13)  {$T_2$};
			\node (t3) at (13,13)  {$T_3$};

			\node (f0) at (4, 10)  {$F_0$};
			\node (f1) at (7, 10)  {$F_1$};
			\node (f2) at (10,10)  {$F_2$};
			\node (f3) at (13,10)  {$F_3$};




			\node (t10) at (2.5,6)  {$t_{10}$};
			\node (t11) at (2.5,4)  {$t_{11}$};
			\node (t12) at (2.5,2)  {$t_{12}$};
			\node (t13) at (2.5,0)  {$t_{13}$};	

			\node (f10) at (4.5,6)  {$f_{10}$};
			\node (f11) at (4.5,4)  {$f_{11}$};
			\node (f12) at (4.5,2)  {$f_{12}$};
			\node (f13) at (4.5,0)  {$f_{13}$};
			  
			\node (f20) at (14.5,6)  {$f_{20}$};
			\node (f21) at (14.5,4)  {$f_{21}$};
			\node (f22) at (14.5,2)  {$f_{22}$};
			\node (f23) at (14.5,0)  {$f_{23}$};

			\node (t20) at (12.5,6)  {$t_{20}$};
			\node (t21) at (12.5,4)  {$t_{21}$};
			\node (t22) at (12.5,2)  {$t_{22}$};
			\node (t23) at (12.5,0)  {$t_{23}$};

			
			


			\node (x1n) at (0,3)  {$\overline{x_1}$};
			\node (x1)  at (7,3)  {$x_1$};
			\node (x2n)  at (10,3)  {$\overline{x_2}$};
			\node (x2) at (17,3)  {$x_2$};


			\foreach \from/\to in {t0/f0,t0/f1,t0/f2,t0/f3,
			t1/f0,t1/f1,t1/f2,t1/f3,
			t3/f0,t3/f1,t3/f2,t3/f3,
			t2/f0,t2/f1,t2/f2,t2/f3}%%%%
			\draw[] (\from) -- (\to);

			\foreach \from/\to in {t10/f10,t11/f11,t12/f12,t13/f13,
			t20/f20,t21/f21,t22/f22,t23/f23}%%%%
			\draw[] (\from) -- (\to);

			\foreach \from/\to in {t10/x1n,t11/x1n,t12/x1n,t13/x1n,
			t20/x2n,t21/x2n,t22/x2n,t23/x2n}
			\draw[] (\from) -- (\to);

			\foreach \from/\to in {x1/f10,x1/f11,x1/f12,x1/f13,
			x2/f20,x2/f21,x2/f22,x2/f23}
			\draw[] (\from) -- (\to);

			\foreach \from/\to in {x1/x2n,x1/f1,x2n/f2}
			\draw[draw=red!60, line width=2.5pt] (\from) -- (\to);
		\end{tikzpicture} \end{center}

		\bigskip
		\bigskip

		Se encontrarmos um corte~$(T,F)$ em~$G$ tal 
		que~$e_G(T, F)\ge |A_1| + 2\cdot k$, 
		então teremos que, para todo vértice do tipo~$x_i$,
		se~$x_i\in T$, a variável que ele representa será
		verdadeira, já se~$x_i\in F$, a variável que ele representa
		será falsa. Tendo que as variáveis possuem os valores conforme
		o que foi dito anteriormente, $k$ ou mais cláusulas serão 
		verdadeiras.

		\bigskip
		\bigskip
		\bigskip
		\bigskip
		\bigskip

		\textbf{Explicação:}

		\bigskip

		Mostraremos agora que para todas as entradas do problema
		Max Sat2, existe uma solução da sua redução para o problema
		Simple Max Cut.
		Para isso, vamos supor que já temos um conjunto de valores
		para as variáveis do problema Max Sat2 de forma que~$k$ ou mais
		cláusulas sejam verdadeiras.

		Sabemos que existem no máximo~$2p$ arestas do 
		tipo~$\{x_i,F_j\}$ ou $\{\overline{x_i},F_j\}$. Dado 
		que~$2p<3p+1$,
		que as funções~$f(i)=2\cdot i - 1$ e~$g(i)=2\cdot i$ têm imagem 
		ímpar e par, respectivamente, e ambas são injetoras, portanto, 
		temos que cada~$F_i$ se liga a apenas um vértice
		do tipo~$x_i$ ou~$\overline{x_i}$.

		Definiremos agora os vértices contidos nos 
		subconjuntos~$T$ e~$F$ de~$G$.
		Suponhamos que para todo~$i\in[0,3p]$,~$T_i\in T$ e~$F_i\in F$ e
		para todo~$j\in[1,n]$ e $k\in[0,3p]$, ~$x_j$ pertence ao 
		mesmo subconjunto que~$t_{jk}$ e ambos
		 não pertencem ao mesmo 
		subconjunto que~$\overline{x_j}$ e que~$f_{jk}$.
		Assim sendo, temos que todas as arestas de~$E_1$ estão no 
		corte~$(T,F)$.
		Suponhamos também que se a variável~$x_i$ é verdadeira,
		então, o vértice~$x_i$ está em $T$, e se mantermos as 
		propriedades que foram citadas anteriormente, isso não afetará o 
		fato de todas as arestas de~$E_1$ estarem no corte~$(T,F)$.
		Portanto, assumiremos inicialmente que essa é a disposição dos 
		vértices nos subconjuntos~$T$ e~$F$.

		Temos que, em uma cláusula~$C_i=(a_i,b_i)$, ou
		apenas uma das literais é satisfeita, ambas são ou nenhuma
		delas é.
		\begin{enumerate}
			\item Se apenas uma das literais é satisfeita, temos que,
			das arestas formadas pela cláusula~$C_i$, duas
			estão no corte~$(T,F)$ e uma está fora.
			\item Se as duas literais são satisfeitas, também teremos
			duas arestas no corte~$(T,F)$ e uma fora.
			\item Já no caso de nenhuma literal ser satisfeita, nenhuma
			dessas arestas da cláusula estará no corte~$(T,F)$.
		\end{enumerate}

		Podemos ver isso de forma mais clara na imagem a seguir.

		\begin{center} \begin{tikzpicture}
			[scale=.24,auto=left,every node/.style={circle, 
			draw=black,
			fill=blue!20}]
			


			\node (t0_) at (4 +20,13)  {};
			\node (t1_) at (7 +20,13)  {};
			\node (t2_) at (10+20,13)  {};
			\node (t3_) at (13+20,13)  {};

			\node [fill=violet!50](f0_) at (4 +20,10)  {};
			\node [fill=violet!50](f1_) at (7 +20,10)  {};
			\node [fill=violet!50](f2_) at (10+20,10)  {};
			\node [fill=violet!50](f3_) at (13+20,10)  {};

			\node (t10_) at (2.5+20,6)  {};
			\node (t11_) at (2.5+20,4)  {};
			\node (t12_) at (2.5+20,2)  {};
			\node (t13_) at (2.5+20,0)  {};	

			\node [fill=violet!50](f10_) at (4.5+20,6)  {};
			\node [fill=violet!50](f11_) at (4.5+20,4)  {};
			\node [fill=violet!50](f12_) at (4.5+20,2)  {};
			\node [fill=violet!50](f13_) at (4.5+20,0)  {};
			  
			\node (f20_) at (14.5+20,6)  {};
			\node (f21_) at (14.5+20,4)  {};
			\node (f22_) at (14.5+20,2)  {};
			\node (f23_) at (14.5+20,0)  {};

			\node [fill=violet!50](t20_) at (12.5+20,6)  {};
			\node [fill=violet!50](t21_) at (12.5+20,4)  {};
			\node [fill=violet!50](t22_) at (12.5+20,2)  {};
			\node [fill=violet!50](t23_) at (12.5+20,0)  {};
			
			\node [fill=violet!50](x1n_) at (0 +20, 3)  {};
			\node (x1_)  at (7 +20, 3)  {};
			\node (x2n_) at (10+20, 3) {};
			\node [fill=violet!50](x2_)  at (17+20, 3) {};






			\node (t0__) at (4 +40,13)  {};
			\node (t1__) at (7 +40,13)  {};
			\node (t2__) at (10+40,13)  {};
			\node (t3__) at (13+40,13)  {};

			\node [fill=violet!50](f0__) at (4 +40,10)  {};
			\node [fill=violet!50](f1__) at (7 +40,10)  {};
			\node [fill=violet!50](f2__) at (10+40,10)  {};
			\node [fill=violet!50](f3__) at (13+40,10)  {};

			\node [fill=violet!50](t10__) at (2.5+40,6)  {};
			\node [fill=violet!50](t11__) at (2.5+40,4)  {};
			\node [fill=violet!50](t12__) at (2.5+40,2)  {};
			\node [fill=violet!50](t13__) at (2.5+40,0)  {};	

			\node (f10__) at (4.5+40,6)  {};
			\node (f11__) at (4.5+40,4)  {};
			\node (f12__) at (4.5+40,2)  {};
			\node (f13__) at (4.5+40,0)  {};
			  
			\node [fill=violet!50](f20__) at (14.5+40,6)  {};
			\node [fill=violet!50](f21__) at (14.5+40,4)  {};
			\node [fill=violet!50](f22__) at (14.5+40,2)  {};
			\node [fill=violet!50](f23__) at (14.5+40,0)  {};

			\node (t20__) at (12.5+40,6)  {};
			\node (t21__) at (12.5+40,4)  {};
			\node (t22__) at (12.5+40,2)  {};
			\node (t23__) at (12.5+40,0)  {};
			
			\node (x1n__) at (0 +40, 3)  {};
			\node [fill=violet!50](x1__)  at (7 +40, 3)  {};
			\node [fill=violet!50](x2n__) at (10+40, 3) {};
			\node (x2__)  at (17+40, 3) {};






			\node (t0) at (4 ,13)  {};
			\node (t1) at (7 ,13)  {};
			\node (t2) at (10,13)  {};
			\node (t3) at (13,13)  {};

			\node [fill=violet!50](f0) at (4 ,10)  {};
			\node [fill=violet!50](f1) at (7 ,10)  {};
			\node [fill=violet!50](f2) at (10,10)  {};
			\node [fill=violet!50](f3) at (13,10)  {};



			\node [fill=violet!50](t10) at (2.5,6)  {};
			\node [fill=violet!50](t11) at (2.5,4)  {};
			\node [fill=violet!50](t12) at (2.5,2)  {};
			\node [fill=violet!50](t13) at (2.5,0)  {};	

			\node (f10) at (4.5,6)  {};
			\node (f11) at (4.5,4)  {};
			\node (f12) at (4.5,2)  {};
			\node (f13) at (4.5,0)  {};
			  
			\node (f20) at (14.5,6)  {};
			\node (f21) at (14.5,4)  {};
			\node (f22) at (14.5,2)  {};
			\node (f23) at (14.5,0)  {};

			\node [fill=violet!50](t20) at (12.5,6)  {};
			\node [fill=violet!50](t21) at (12.5,4)  {};
			\node [fill=violet!50](t22) at (12.5,2)  {};
			\node [fill=violet!50](t23) at (12.5,0)  {};


			\node (x1n) at (0,3)  {};
			\node [fill=violet!50](x1)  at (7,3)  {};
			\node (x2n) at (10,3) {};
			\node [fill=violet!50](x2)  at (17,3) {};



			\node (l1) at (1,-7)  {};
			\node [fill=violet!50](l2)  at (1,-5)  {};
			\node [draw=none, fill=none] at 
				(7,-5) {\small{vértice de $F$}};
			\node [draw=none, fill=none] at 
				(7,-7) {\small{vértice de $T$}};
			\node [draw=none, fill=none](a1) at (35,-5) {};
			\node [draw=none, fill=none](a1_) at (39,-5) {};
			\node [draw=none, fill=none](a2) at (35,-7) {};
			\node [draw=none, fill=none](a2_) at (39,-7) {};
			\node [draw=none, fill=none] at 
				(45,-5) {\small{aresta $\in(T,F)$}};
			\node [draw=none, fill=none] at 
				(45,-7) {\small{aresta $\not\in(T,F)$}};
			\foreach \from/\to in {t0_/f0_,t0_/f1_,t0_/f2_,t0_/f3_,
			t1_/f0_,t1_/f1_,t1_/f2_,t1_/f3_,
			t3_/f0_,t3_/f1_,t3_/f2_,t3_/f3_,
			t2_/f0_,t2_/f1_,t2_/f2_,t2_/f3_}%%%%
			\draw[] (\from) -- (\to);

			\foreach \from/\to in 
			{t10_/f10_,t11_/f11_,t12_/f12_,t13_/f13_,
			t20_/f20_,t21_/f21_,t22_/f22_,t23_/f23_}%%%%
			\draw[] (\from) -- (\to);

			\foreach \from/\to in 
			{t10_/x1n_,t11_/x1n_,t12_/x1n_,t13_/x1n_,
			t20_/x2n_,t21_/x2n_,t22_/x2n_,t23_/x2n_}
			\draw[] (\from) -- (\to);

			\foreach \from/\to in 
			{x1_/f10_,x1_/f11_,x1_/f12_,x1_/f13_,
			x2_/f20_,x2_/f21_,x2_/f22_,x2_/f23_,x1_/f1_,x2n_/f2_}
			\draw[] (\from) -- (\to);

			\foreach \from/\to in {x1_/x2n_}
			\draw[draw=red!60, line width=2.7pt] (\from) -- (\to);


			

			\foreach \from/\to in {t0__/f0__,t0__/f1__,t0__/f2__,t0__/f3__,
			t1__/f0__,t1__/f1__,t1__/f2__,t1__/f3__,
			t3__/f0__,t3__/f1__,t3__/f2__,t3__/f3__,
			t2__/f0__,t2__/f1__,t2__/f2__,t2__/f3__}%%%%
			\draw[] (\from) -- (\to);

			\foreach \from/\to in 
			{t10__/f10__,t11__/f11__,t12__/f12__,t13__/f13__,
			t20__/f20__,t21__/f21__,t22__/f22__,t23__/f23__}%%%%
			\draw[] (\from) -- (\to);

			\foreach \from/\to in 
			{t10__/x1n__,t11__/x1n__,t12__/x1n__,t13__/x1n__,
			t20__/x2n__,t21__/x2n__,t22__/x2n__,t23__/x2n__}
			\draw[] (\from) -- (\to);

			\foreach \from/\to in 
			{x1__/f10__,x1__/f11__,x1__/f12__,x1__/f13__,
			x2__/f20__,x2__/f21__,x2__/f22__,x2__/f23__,a1/a1_}
			\draw[] (\from) -- (\to);

			\foreach \from/\to in {x1__/x2n__,x1__/f1__,x2n__/f2__,a2/a2_}
			\draw[draw=red!60, line width=2.7pt] (\from) -- (\to);




			\foreach \from/\to in {t0/f0,t0/f1,t0/f2,t0/f3,
			t1/f0,t1/f1,t1/f2,t1/f3,
			t3/f0,t3/f1,t3/f2,t3/f3,
			t2/f0,t2/f1,t2/f2,t2/f3}%%%%
			\draw[] (\from) -- (\to);

			\foreach \from/\to in {t10/f10,t11/f11,t12/f12,t13/f13,
			t20/f20,t21/f21,t22/f22,t23/f23}%%%%
			\draw[] (\from) -- (\to);

			\foreach \from/\to in {t10/x1n,t11/x1n,t12/x1n,t13/x1n,
			t20/x2n,t21/x2n,t22/x2n,t23/x2n}
			\draw[] (\from) -- (\to);

			\foreach \from/\to in {x1/f10,x1/f11,x1/f12,x1/f13,
			x2/f20,x2/f21,x2/f22,x2/f23,x2n/f2,x1/x2n}
			\draw[] (\from) -- (\to);

			\foreach \from/\to in {x1/f1}
			\draw[draw=red!60, line width=2.7pt] (\from) -- (\to);
		\end{tikzpicture} \end{center}

		Sabe-se que temos~$2k$ ou mais arestas de~$E_1$ que estão no
		corte~$(T,F)$, pois, para cada uma das~$k$ cláusulas
		verdadeiras, teremos duas arestas de~$E_1$ no corte, como
		o mostrado anteriormente.

		Se houvesse alguma aresta duplicada (duas arestas que ligam
		os mesmos vértices), teríamos um problema na contagem de
		arestas dentro e fora do corte.
		Isso poderia ocorrer no caso de duas cláusulas serem 
		idênticas,~$C_i=C_j=(a_i,b_i)$.
		Isso faria com que houvesse uma aresta duplicada entre
		os vértices~$a_1$ e~$b_i$, mas isso não acontece, dado que
		no enunciado é assumido que as cláusulas são distintas.
		Também não há o problema de dois vértices estarem em cláusulas
		diferentes, dado que para cada cláusula, os vértices se ligam
		a um~$F_i$ diferente.
		E mesmo se repetirmos as variáveis na mesma cláusula, cada
		elemento da cláusula se ligará a um~$F_i$ diferente.

		\bigskip

		Mostramos que existe uma solução, em Simple Max Cut, 
		para todas as entradas do
		problema MaxSat2 reduzidas para Simple Max Cut, de forma que
		a solução do Simple Max Cut leva a uma solução de Max Sat2.
		Agora mostraremos que qualquer solução obtida em 
		uma redução para Simple Max Cut levará a uma solução de Max Sat2.

	\subsection{Redução SimpleMaxCut para Bissecção}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%  SEÇÃO 11    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section {Algoritmo de Jansen 11}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%  SEÇÃO 12    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage

\section {Geração de árvores binárias aleatórias}
	Nesta seção falaremos sobre o gerador de árvores binárias 
	aleatórias, um dos tipos de árvores que foi utilizado nos 
	testes do algoritmo FST.

	As árvores binárias aleatórias são árvores com um número 
	pré-definido de vértices, que são construídas aleatoriamente e 
	onde cada nó possui no máximo dois filhos.

	O gerador recebe um inteiro~$n$ e cria um vetor permutado 
	aleatoriamente com valores de~$0$ a~$n-1$.
	Depois, constrói uma árvore binária de busca e vai inserindo 
	os nós de acordo com a ordem dada pelo vetor.
	Isso leva tempo~$O(n^2)$, dado que a inserção na árvore 
	binária de busca leva tempo linear para cada um dos~$n$ nós.

	Segue abaixo o algoritmo do gerador.
	\bigskip
	\bigskip

	\begin{algorithm}[H]
	\label{alg:insertion}
		\SetKwInOut{Input}{input}
		\SetKwInOut{Output}{output}

		\caption{Inserção do nó $n$ na árvore binária de busca}
		\Input{raiz $r$ da árvore e nó $n$}
		\Output{}
		\eIf {$n.chave>r.chave$}
		{
			\eIf{$r.right = NULL$}{
				$r.right\gets n$\; 
			}
			{
				Algoritmo \ref{alg:insertion}$(r.right,~n)$\;
			}
		}
		{
			\eIf{$r.left = NULL$}{
				$r.left\gets n$\; 
			}
			{
				Algoritmo \ref{alg:insertion}$(r.left, ~n)$\;
			}
		}

	\end{algorithm}	

	\bigskip

	\begin{algorithm}[H]
	\label{alg:ABAgenerator}
		\SetKwInOut{Input}{input}
		\SetKwInOut{Output}{output}

		\caption{Gerador de árvores binárias aleatórias}
		\Input{inteiro $n$}
		\Output{raiz da árvore binária aleatória gerada}
		\bigskip
		\tcp{Aleatoriza vetor}
		\For {$i = 0 \to n-1$}
		{
			$v[i] \gets i$\;
		}

		\For {$i = n-1 \to 1$}{
			$indice \gets$ RANDOM$(0\ldots i)$\;
			$v[indice] \leftrightarrow v[i]$\;
		}
		\bigskip
		\tcp{Inserção dos elementos do vetor na árvore binária de
		busca}
		$raiz.chave\gets v[0]$\;
		\For{$i=1\to n-1$}
		{
			new $no.chave\gets v[i]$\;
			Algoritmo~\ref{alg:insertion}$(raiz$, $no)$\;
		}
		\Return $raiz$\;

	\end{algorithm}	

	\bigskip
	\bigskip

	Nota-se que numa árvore desse tipo, em grande parte dos 
	casos, a maioria dos nós estará presente no caminho mais 
	longo. 
	O que favorece um pouco o algoritmo FST.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%  SEÇÃO 13    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\newpage
\section {Experimentos computacionais 13}

	\subsection{Árvores Binárias Aleatórias}
	% \begin{table}[htbf]
	% 	\centering
	% 	\caption {Random Binary Trees}
	% 	\begin{tabular}{ c|c | >{\columncolor{blue!14}}c | >{\columncolor{red!14}}c | >{\columncolor{blue!14}}c | >{\columncolor{red!14}}c }
	% 		\specialrule{1.7pt}{1pt}{1pt}
	% 		$|V(T)|$ & seed & $e_T(B,W)$ - \textbf{FST} & $e_T(B,W)$ - \textbf{Jansen} & Tempo - \textbf{FST} & Tempo - \textbf{Jansen}  \\[10pt]

	% 		\specialrule{1.7pt}{1pt}{1pt}
	% 		\multirow{10}*{100} & 1  & 2   & 2  & 0.000146  & 0.002095 \\[3pt]\cmidrule{2-6} 
	% 	                        & 2  & 2   & 2  & 0.000187  & 0.002130 \\[3pt]\cmidrule{2-6}
	% 		                    & 3  & 2   & 2  & 0.000158  & 0.002440 \\[3pt]\cmidrule{2-6}
	% 		                    & 4  & 2   & 2  & 0.000142  & 0.001993 \\[3pt]\cmidrule{2-6}
	% 		                    & 5  & 3   & 2  & 0.000188  & 0.000967 \\[3pt]\cmidrule{2-6}
	% 		                    & 6  & 3   & 2  & 0.000185  & 0.001003 \\[3pt]\cmidrule{2-6}
	% 		                    & 7  & 2   & 2  & 0.000131  & 0.001005 \\[3pt]\cmidrule{2-6}
	% 		                    & 8  & 5   & 2  & 0.000183  & 0.000884 \\[3pt]\cmidrule{2-6}
	% 		                    & 9  & 2   & 2  & 0.000176  & 0.001037 \\[3pt]\cmidrule{2-6}
	% 		                    & 10 & 2   & 2  & 0.000130  & 0.001030 \\[3pt]

	% 		\specialrule{1.7pt}{1pt}{1pt}
		 
	% 	\end{tabular}
	% \end{table}


		\subsection{Árvores Balanceadas}
		\subsection{Árvores de Caminho Longo}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%  SEÇÃO 14    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section {Conclusões 14}



\newpage
\bibliographystyle{plain}
\bibliography{refs}
\end{document}
